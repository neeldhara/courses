{"title":"Advanced Algorithms. Week 1 Practice Problems","markdown":{"yaml":{"css":"/css/teaching.css","toc":false,"sidebar":false,"title":"Advanced Algorithms. Week 1 Practice Problems","code-copy":true},"headingText":"Advanced Algorithms.","containsRefs":false,"markdown":"\n\n:::{.column-body-outset}\n\n\n##### Week 1 Practice Problems\n\n[Back to the course page](../index.qmd)\n\n\n:::{.callout-tip icon=\"false\"}\n# Acknowledgements\nThese questions are from Chapter 4 of [Jeff Erickson](http://jeffe.cs.illinois.edu/)'s [textbook on Algorithms](http://jeffe.cs.illinois.edu/teaching/algorithms/). \n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1. Alternate Greedy Schedules\n\nThe `GreedySchedule` algorithm we described for the class scheduling problem is not the only greedy strategy we could have tried. For each of the following alternative greedy strategies, either prove that the resulting algorithm always constructs an optimal schedule, or describe a small input example for which the algorithm does not produce an optimal schedule. \n\n_Assume that all algorithms break ties arbitrarily (that is, in a manner that is completely out of your control)._\n\n[Hint: Three of these algorithms are actually correct.]\n\n(a) Choose the course $x$ that ends last, discard classes that conflict with $x$, and recurse.\n\n(b) Choose the course $x$ that starts first, discard all classes that conflict with $x$, and recurse.\n\n(c) Choose the course $x$ that starts last, discard all classes that conflict with $x$, and recurse.\n\n(d) Choose the course $x$ with shortest duration, discard all classes that conflict with $x$, and recurse.\n\n(e) Choose a course $x$ that conflicts with the fewest other courses, discard all classes that conflict with $x$, and recurse.\n\n(f) If no classes conflict, choose them all. Otherwise, discard the course with longest duration and recurse.\n\n(g) If no classes conflict, choose them all. Otherwise, discard a course that conflicts with the most other courses and recurse.\n\n(h) Let $x$ be the class with the earliest start time, and let $y$ be the class with the second earliest start time.\n\n- If $x$ and $y$ are disjoint, choose $x$ and recurse on everything but $x$.\n\n- If $x$ completely contains $y$, discard $x$ and recurse.\n\n- Otherwise, discard $y$ and recurse.\n\n(i) If any course $x$ completely contains another course, discard $x$ and recurse. Otherwise, choose the course $y$ that ends last, discard all classes that conflict with $y$, and recurse.\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2. Weighted Scheduling\n\nNow consider a weighted version of the class scheduling problem, where different classes offer different number of credit hours (totally unrelated to the duration of the class lectures). Your goal is now to choose a set of non-conflicting classes that give you the largest possible number of credit hours, given arrays of start times, end times, and credit hours as input.\n\n(a) Prove that the greedy algorithm described at the beginning of this chapter-Choose the class that ends first and recurse-does not always return an optimal schedule.\n\n(b) Prove that none of the greedy algorithms described in Exercise 1 always return an optimal schedule. [Hint: Solve Exercise 1 first; the algorithms that don't work there don't work here, either.] \n\n(c) `BONUS QUESTION` Describe and analyze an algorithm that always computes an optimal schedule. [Hint: Your algorithm will not be greedy.]\n\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3. Finding a Cover\n\nLet $X$ be a set of $n$ intervals on the real line. We say that a subset of intervals $Y \\subseteq X$ covers $X$ if the union of all intervals in $Y$ is equal to the union of all intervals in $X$. The size of a cover is just the number of intervals.\n\nDescribe and analyze an efficient algorithm to compute the smallest cover of $X$. Assume that your input consists of two arrays $L[1 \\ldots n]$ and $R[1 . . n]$, representing the left and right endpoints of the intervals in $X$. If you use a greedy algorithm, you must prove that it is correct.\n\n![A set of intervals, with a cover (shaded) of size 7.](P01-1.jpg)\n\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4. Finding a Stabbing Set\n\nLet $X$ be a set of $n$ intervals on the real line. We say that a set $P$ of points stabs $X$ if every interval in $X$ contains at least one point in $P$. Describe and analyze an efficient algorithm to compute the smallest set of points that stabs $X$. Assume that your input consists of two arrays $L[1 . . n]$ and $R[1 . . n]$, representing the left and right endpoints of the intervals in $X$. As usual, If you use a greedy algorithm, you must prove that it is correct.\n\n![A set of intervals stabbed by four points (shown here as vertical segments).](P01-2.jpg)\n\n\n\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 5. Proper Coloring\n\nLet $X$ be a set of $n$ intervals on the real line. A proper coloring of $X$ assigns a color to each interval, so that any two overlapping intervals are assigned different colors. Describe and analyze an efficient algorithm to compute the minimum number of colors needed to properly color $X$. Assume that your input consists of two arrays $L[1 . . n]$ and $R[1 . . n]$, representing the left and right endpoints of the intervals in $X$. As usual, if you use a greedy algorithm, you must prove that it is correct.\n\n![A proper coloring of a set of intervals using five colors.](P01-3.jpg)\n\n:::\n\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 6. Stable Matchings\n\n(a) Prove that it is possible for the Gale-Shapley algorithm to perform $\\Omega\\left(n^{2}\\right)$ offers before termination. \n\n    (You need to describe both a suitable input and a sequence of $\\Omega\\left(n^{2}\\right)$ valid offers.)\n\n(b) Describe for any integer $n$ a set of preferences for $n$ men and $n$ women that forces the Gale-Shapley algorithm to execute $\\Omega\\left(n^{2}\\right)$ rounds, no matter which valid proposal is made in each round. \n\n    [Hint: Part (b) implies part (a).]\n\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 7. A Unique Stable Matching\n\nDescribe and analyze an efficient algorithm to determine whether a given set of men and women preferences has to have a unique stable matching.\n\n\n:::\n\n\n\n\n\n\n\n:::","srcMarkdownNoYaml":"\n\n:::{.column-body-outset}\n\n## Advanced Algorithms. \n\n##### Week 1 Practice Problems\n\n[Back to the course page](../index.qmd)\n\n\n:::{.callout-tip icon=\"false\"}\n# Acknowledgements\nThese questions are from Chapter 4 of [Jeff Erickson](http://jeffe.cs.illinois.edu/)'s [textbook on Algorithms](http://jeffe.cs.illinois.edu/teaching/algorithms/). \n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1. Alternate Greedy Schedules\n\nThe `GreedySchedule` algorithm we described for the class scheduling problem is not the only greedy strategy we could have tried. For each of the following alternative greedy strategies, either prove that the resulting algorithm always constructs an optimal schedule, or describe a small input example for which the algorithm does not produce an optimal schedule. \n\n_Assume that all algorithms break ties arbitrarily (that is, in a manner that is completely out of your control)._\n\n[Hint: Three of these algorithms are actually correct.]\n\n(a) Choose the course $x$ that ends last, discard classes that conflict with $x$, and recurse.\n\n(b) Choose the course $x$ that starts first, discard all classes that conflict with $x$, and recurse.\n\n(c) Choose the course $x$ that starts last, discard all classes that conflict with $x$, and recurse.\n\n(d) Choose the course $x$ with shortest duration, discard all classes that conflict with $x$, and recurse.\n\n(e) Choose a course $x$ that conflicts with the fewest other courses, discard all classes that conflict with $x$, and recurse.\n\n(f) If no classes conflict, choose them all. Otherwise, discard the course with longest duration and recurse.\n\n(g) If no classes conflict, choose them all. Otherwise, discard a course that conflicts with the most other courses and recurse.\n\n(h) Let $x$ be the class with the earliest start time, and let $y$ be the class with the second earliest start time.\n\n- If $x$ and $y$ are disjoint, choose $x$ and recurse on everything but $x$.\n\n- If $x$ completely contains $y$, discard $x$ and recurse.\n\n- Otherwise, discard $y$ and recurse.\n\n(i) If any course $x$ completely contains another course, discard $x$ and recurse. Otherwise, choose the course $y$ that ends last, discard all classes that conflict with $y$, and recurse.\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2. Weighted Scheduling\n\nNow consider a weighted version of the class scheduling problem, where different classes offer different number of credit hours (totally unrelated to the duration of the class lectures). Your goal is now to choose a set of non-conflicting classes that give you the largest possible number of credit hours, given arrays of start times, end times, and credit hours as input.\n\n(a) Prove that the greedy algorithm described at the beginning of this chapter-Choose the class that ends first and recurse-does not always return an optimal schedule.\n\n(b) Prove that none of the greedy algorithms described in Exercise 1 always return an optimal schedule. [Hint: Solve Exercise 1 first; the algorithms that don't work there don't work here, either.] \n\n(c) `BONUS QUESTION` Describe and analyze an algorithm that always computes an optimal schedule. [Hint: Your algorithm will not be greedy.]\n\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3. Finding a Cover\n\nLet $X$ be a set of $n$ intervals on the real line. We say that a subset of intervals $Y \\subseteq X$ covers $X$ if the union of all intervals in $Y$ is equal to the union of all intervals in $X$. The size of a cover is just the number of intervals.\n\nDescribe and analyze an efficient algorithm to compute the smallest cover of $X$. Assume that your input consists of two arrays $L[1 \\ldots n]$ and $R[1 . . n]$, representing the left and right endpoints of the intervals in $X$. If you use a greedy algorithm, you must prove that it is correct.\n\n![A set of intervals, with a cover (shaded) of size 7.](P01-1.jpg)\n\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4. Finding a Stabbing Set\n\nLet $X$ be a set of $n$ intervals on the real line. We say that a set $P$ of points stabs $X$ if every interval in $X$ contains at least one point in $P$. Describe and analyze an efficient algorithm to compute the smallest set of points that stabs $X$. Assume that your input consists of two arrays $L[1 . . n]$ and $R[1 . . n]$, representing the left and right endpoints of the intervals in $X$. As usual, If you use a greedy algorithm, you must prove that it is correct.\n\n![A set of intervals stabbed by four points (shown here as vertical segments).](P01-2.jpg)\n\n\n\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 5. Proper Coloring\n\nLet $X$ be a set of $n$ intervals on the real line. A proper coloring of $X$ assigns a color to each interval, so that any two overlapping intervals are assigned different colors. Describe and analyze an efficient algorithm to compute the minimum number of colors needed to properly color $X$. Assume that your input consists of two arrays $L[1 . . n]$ and $R[1 . . n]$, representing the left and right endpoints of the intervals in $X$. As usual, if you use a greedy algorithm, you must prove that it is correct.\n\n![A proper coloring of a set of intervals using five colors.](P01-3.jpg)\n\n:::\n\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 6. Stable Matchings\n\n(a) Prove that it is possible for the Gale-Shapley algorithm to perform $\\Omega\\left(n^{2}\\right)$ offers before termination. \n\n    (You need to describe both a suitable input and a sequence of $\\Omega\\left(n^{2}\\right)$ valid offers.)\n\n(b) Describe for any integer $n$ a set of preferences for $n$ men and $n$ women that forces the Gale-Shapley algorithm to execute $\\Omega\\left(n^{2}\\right)$ rounds, no matter which valid proposal is made in each round. \n\n    [Hint: Part (b) implies part (a).]\n\n:::\n\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 7. A Unique Stable Matching\n\nDescribe and analyze an efficient algorithm to determine whether a given set of men and women preferences has to have a unique stable matching.\n\n\n:::\n\n\n\n\n\n\n\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["fontawesome"],"css":["../../../styles.css","/css/teaching.css"],"toc":false,"include-in-header":[{"text":"<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Berkshire+Swash&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap\" rel=\"stylesheet\">\n<link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n<script>\nwindow.addEventListener('load', function() {\n  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')); \n  tooltipTriggerList.forEach(function(element) {\n    new bootstrap.Tooltip(element, {\n      trigger: 'hover',\n      animation: true,\n      delay: { show: 50, hide: 50 }\n    });\n  });\n});\n</script>\n"}],"output-file":"P01.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo","js":"../../../scripts.js","page-layout":"full","sidebar":false,"title":"Advanced Algorithms. Week 1 Practice Problems","code-copy":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
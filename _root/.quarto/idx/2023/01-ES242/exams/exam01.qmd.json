{"title":"ES242. Data Structures and Algorithms I. Exam 01","markdown":{"yaml":{"css":"/css/teaching.css","toc":false,"sidebar":false,"title":"ES242. Data Structures and Algorithms I. Exam 01","code-copy":true},"headingText":"ES242. Data Structures and Algorithms I.","containsRefs":false,"markdown":"\n\n:::{.column-body-outset}\t\n\n\n##### Exam 01 \n\nIssued: 16 Feb, 2023\n\n[Back to course page](../index.qmd)\n\n\n\n:::{.callout-caution icon=\"false\"} \n\n# Instructions\n\nWe will have Exam 1 at the usual classroom venue. The exam will be released on Gradescope by 9:05PM, and will be available until 10:30PM.\n\nAll questions are multiple choice or require a numeric answer. Do not enter any explanations for any questions. If required, we will follow up with individual vivas to understand any alternate explanations you had in mind.\n\nYou have been asked to rate your confidence for all answers that you give. Please see [this slide](https://docs.google.com/presentation/d/1zHliTFMs5YCp7OHb5J1DXXOIWBmIoAuviOwurkIDKLQ/edit?usp=sharing) for the grading scheme and instructions.\n\nAny violations of the honor code (in particular including, but not limited to, communicating during the quiz, or using the internet for anything other than looking up the official course materials) will be reported and will result in a F grade in the course.\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 1. The Rubik's Cube\n\nThe Rubik's Cube is a 3-D combination puzzle involving a cube with a grid of nine squares on each face. In a solved state, each face of the cube has all the nine squares colored using one of six solid colours: white, red, blue, orange, green, and yellow. \n\n![A Rubik Cube](images.jpg)\n\nThe arrangement of colours is now standardised with white opposite yellow, blue opposite green, and orange opposite red, and the red, white, and blue arranged clockwise in that order.\n\nAn internal pivot mechanism enables each face to turn independently, thus mixing up the colours. For the puzzle to be solved, each face must be returned to have only one colour. \n\nSuppose you are implementing a Rubik Cube solver. To answer these questions, you _do not_ need to know how to solve a Rubik's cube. We assume that the cube is in a fixed orientation, so that that we can identify the front, back, top, bottom, left, and right faces in the natural way.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.1 \nOne natural way to store the state of the cube is to use six 3x3 arrays of chars, with each character representing a color: `cube-front[3][3]`, `cube-back[3][3]`, `cube-top[3][3]`, `cube-bottom[3][3]`, `cube-left[3][3]`, `cube-right[3][3]`.\n\nIn this representation, to get the color of the sticker on the top-left corner of the front face, you would check the value of `cube-front[0][0]`. \n\nIn general, for a face `F`, to get the color of the sticker on row `R` and column `C`, you will check the value of `cube-F[R][C]`.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. Which array would remain unchanged?\n\n- `cube-front[3][3]`\n- `cube-back[3][3]`\n- `cube-top[3][3]`\n- `cube-bottom[3][3]`\n- `cube-left[3][3]`\n- `cube-right[3][3]`\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.2 \nConsider the following approach. Instead of storing six separate two-dimensional arrays, we store the state of the cube as a linked list with 54 entries as depicted below, by listing all the elements in the `cube-front` array first, followed by `cube-back`, `cube-top`, `cube-bottom`, `cube-left`, `cube-right`. The elements within a face are listed row-wise (i.e, all elements of the first row are listed first, second row second, and so on).\n\n![Transforming the arrays to a linked list](fromarray-to-ll.png)\n\nSuppose you want to determine the color of a sticker at a particular location, which is specified by the face, row number, and column number. Which approach will require _more_ steps?\n\n- The array approach\n- The linked list approach\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.3 \nConsider the linked list approach from the previous question. What is the index of the element that stores the color of the center sticker (i.e, row 1 and column 1 with 0-based indexing) of the bottom face? Assume that the linked list is 1-indexed: for example the index of the element that stores the color of the center sticker for the front face is `5`.\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.4 \nObserve that the central pieces of each face in a Rubik's cube do not move with any of the rotations. We can think of the Rubik's cube as being assembled from 8 corner pieces and 12 edge pieces as shown below. Each of these individual pieces is called a _cubie_.\n\n\n![Cubies](cubies.png)\n\nObserve that the state of the cube can be fully specified by specifying the orientation of all the cubies. Fix a labeling of all the corner cubies from `0` to `7` and the edge cubies from `0` to `11`.\n\nIn particular, let us say that we store the state by storing two _orientation_ arrays and two _location_ arrays.\n\nThe first array, `C` stores the orientation of the corner cubies and the second array `E`, stores the orientation of edge cubies. The elements of each array stores an orientation (0 or 1 for edges; 0, 1, or 2 for corners). \n\nThe third array, `CC` stores the location of the corner cubies and the fourth array `EE`, stores the location of edge cubies. The elements of `CC` are values between `0` and `7` and the elements of `EE` are values between `0` and `11`. \n\nThe state can be recovered from the orientations of all the cubies: for example, we know that the edge cubie with label `3` is at the location `EE[3]`, and oriented according to the value stored in `E[3]`.\n\nWhich data structure for representing the state of a Rubik's cube takes up the least space? Assume that we are measuring the space in terms of the total lengths of the sequences involved in each representation.\n\n- the first approach with six 2D arrays\n- the second approach using a linked list\n- the current approach using two cubie arrays\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.5 \nConsider the representation involving cubies described in the previous part.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. How many values would you have to update in the `CC` array?\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.6\nConsider the representation involving cubies described in the previous part.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. How many values would you have to update in the `EE` array?\n:::\n\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 2. Stable Matchings\n\nRecall that the stable matching problem involves N men and N women. Each man has a ranking of all N women and each woman has a ranking of all N men. A matching M is a collection of N pairs where each pair consists of a man and a woman, and all the men and women appear in exactly one pair. A man `a` and a woman `b` are said to _block_ M if `a` prefers `b` over his matched partner in M and `b` prefers `a` over her matched partner in M according to their respective rankings. A matching is _stable_ if there are no blocking pairs with respect to it.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2.1\nSuppose X and Y are two stable matchings. For a man `a`, let `X[a]` denote the matched partner of `a` in the matching `X` and let `Y[a]` denote the matched partner of `a` in the matching `Y`.\n\nConsider a matching Z formed as follows: pair up each man `a` with the woman he prefers _more_ between `X[a]` and `Y[a]`. \n\nNote: If `X[a]` and `Y[a]` happen to be the same woman `b`, then pair `a` with `b`.\n\nWhat can we say about Z?\n\n- Z is not necessarily a matching.\n- Z is a matching but not necessarily stable.\n- Z is always a stable matching.\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2.2\nSuppose X and Y are two stable matchings. For a man `a`, let `X[a]` denote the matched partner of `a` in the matching `X` and let `Y[a]` denote the matched partner of `a` in the matching `Y`.\n\nConsider a matching Z formed as follows: pair up each man `a` with the woman he prefers _less_ between `X[a]` and `Y[a]`. \n\nNote: If `X[a]` and `Y[a]` happen to be the same woman `b`, then pair `a` with `b`.\n\nWhat can we say about Z?\n\n- Z is not necessarily a matching.\n- Z is a matching but not necessarily stable.\n- Z is always a stable matching.\n:::\n\n:::\n\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 3. An Array and A Virus\n\nThe memory of Rubina's computer contains two interesting things: an array of integers and a virus. Each midnight the virus becomes active. It takes each array in memory and _replaces_ it with a bunch of new arrays: one for each contiguous subarray of the original array.\n\nFor example, if today the memory contains a single array `(1,2,1,3)`, tomorrow it will contain the following arrays: `(1), (2), (1), (3), (1,2), (2,1), (1,3), (1,2,1), (2,1,3), (1,2,1,3)`.\n\nAs another example, if today the memory contains a single array `(7,7)`, tomorrow it will contain the following arrays: `(7), (7), (7,7)`, and the day after tomorrow it will contain the following arrays: `(7), (7), (7), (7), (7,7)`, and so on. \n\nYou are given Rubina's original array $A$ and the number of days $D$. Let $f(A,D)$ be the sum of all elements of all arrays that will be in the memory of Rubina's computer after D days. Our goal is to calculate $f(A,D)$. You may assume that the memory of Rubina's computer is sufficiently large to accommodate all the arrays.\n\nFor example, if $A$ is the array `(1,2,1,3)` and $D = 0$ then the answer is `7`.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.1\nIf A = `(1,2,1,3)` and $D = 1$, what is $f(A,D)$?\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 34\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.2\n\nIf $A =$ `(500)` and $D = 120$, what is $f(A,D)$?\n\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 500\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.3 \n\nIf A = `(1,2)` and $D = 10$, what is $f(A,D)$?\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 33\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.4\n\nIf $A$ has four elements, how many arrays of length _one_ are there after two steps? \n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 20\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n\n:::\n\n:::\n\n::: Problem 4. A Bit of a Graph\n\nThe bit strings of length four are given by:\n\n`0000`, `0001`, `0010`, `0011`, `0100`, `0101`, `0110`, `0111`, `1000`, `1001`, `1010`, `1011`, `1100`, `1101`, `1110`, `1111`.\n\nConsider a graph where we have:\n\n- a vertex for every bit string of length _four_, and let us say that the bit string associated with a vertex $u$ is denoted by $b_u$; and\n- an edge from $u$ to $v$ if the corresponding bit strings are such that the last three bits of $b_u$ is the same as the first three bits of $b_v$.\n\nFor example, we will have an edge from the vertex representing `0010` to the vertex representing `0101`. We will also have an edge from the vertex representing `0010` to the vertex representing `0100`. \n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.1\n\nHow many vertices does this graph have?\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.2\n\nHow many edges does this graph have?\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.3\n\nHow many vertices in this graph have a self-loop?\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.4\n\nDoes this graph have a closed Euler Tour?\n\n:::\n\n:::\n\n\n:::","srcMarkdownNoYaml":"\n\n:::{.column-body-outset}\t\n\n## ES242. Data Structures and Algorithms I.\n\n##### Exam 01 \n\nIssued: 16 Feb, 2023\n\n[Back to course page](../index.qmd)\n\n\n\n:::{.callout-caution icon=\"false\"} \n\n# Instructions\n\nWe will have Exam 1 at the usual classroom venue. The exam will be released on Gradescope by 9:05PM, and will be available until 10:30PM.\n\nAll questions are multiple choice or require a numeric answer. Do not enter any explanations for any questions. If required, we will follow up with individual vivas to understand any alternate explanations you had in mind.\n\nYou have been asked to rate your confidence for all answers that you give. Please see [this slide](https://docs.google.com/presentation/d/1zHliTFMs5YCp7OHb5J1DXXOIWBmIoAuviOwurkIDKLQ/edit?usp=sharing) for the grading scheme and instructions.\n\nAny violations of the honor code (in particular including, but not limited to, communicating during the quiz, or using the internet for anything other than looking up the official course materials) will be reported and will result in a F grade in the course.\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 1. The Rubik's Cube\n\nThe Rubik's Cube is a 3-D combination puzzle involving a cube with a grid of nine squares on each face. In a solved state, each face of the cube has all the nine squares colored using one of six solid colours: white, red, blue, orange, green, and yellow. \n\n![A Rubik Cube](images.jpg)\n\nThe arrangement of colours is now standardised with white opposite yellow, blue opposite green, and orange opposite red, and the red, white, and blue arranged clockwise in that order.\n\nAn internal pivot mechanism enables each face to turn independently, thus mixing up the colours. For the puzzle to be solved, each face must be returned to have only one colour. \n\nSuppose you are implementing a Rubik Cube solver. To answer these questions, you _do not_ need to know how to solve a Rubik's cube. We assume that the cube is in a fixed orientation, so that that we can identify the front, back, top, bottom, left, and right faces in the natural way.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.1 \nOne natural way to store the state of the cube is to use six 3x3 arrays of chars, with each character representing a color: `cube-front[3][3]`, `cube-back[3][3]`, `cube-top[3][3]`, `cube-bottom[3][3]`, `cube-left[3][3]`, `cube-right[3][3]`.\n\nIn this representation, to get the color of the sticker on the top-left corner of the front face, you would check the value of `cube-front[0][0]`. \n\nIn general, for a face `F`, to get the color of the sticker on row `R` and column `C`, you will check the value of `cube-F[R][C]`.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. Which array would remain unchanged?\n\n- `cube-front[3][3]`\n- `cube-back[3][3]`\n- `cube-top[3][3]`\n- `cube-bottom[3][3]`\n- `cube-left[3][3]`\n- `cube-right[3][3]`\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.2 \nConsider the following approach. Instead of storing six separate two-dimensional arrays, we store the state of the cube as a linked list with 54 entries as depicted below, by listing all the elements in the `cube-front` array first, followed by `cube-back`, `cube-top`, `cube-bottom`, `cube-left`, `cube-right`. The elements within a face are listed row-wise (i.e, all elements of the first row are listed first, second row second, and so on).\n\n![Transforming the arrays to a linked list](fromarray-to-ll.png)\n\nSuppose you want to determine the color of a sticker at a particular location, which is specified by the face, row number, and column number. Which approach will require _more_ steps?\n\n- The array approach\n- The linked list approach\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.3 \nConsider the linked list approach from the previous question. What is the index of the element that stores the color of the center sticker (i.e, row 1 and column 1 with 0-based indexing) of the bottom face? Assume that the linked list is 1-indexed: for example the index of the element that stores the color of the center sticker for the front face is `5`.\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.4 \nObserve that the central pieces of each face in a Rubik's cube do not move with any of the rotations. We can think of the Rubik's cube as being assembled from 8 corner pieces and 12 edge pieces as shown below. Each of these individual pieces is called a _cubie_.\n\n\n![Cubies](cubies.png)\n\nObserve that the state of the cube can be fully specified by specifying the orientation of all the cubies. Fix a labeling of all the corner cubies from `0` to `7` and the edge cubies from `0` to `11`.\n\nIn particular, let us say that we store the state by storing two _orientation_ arrays and two _location_ arrays.\n\nThe first array, `C` stores the orientation of the corner cubies and the second array `E`, stores the orientation of edge cubies. The elements of each array stores an orientation (0 or 1 for edges; 0, 1, or 2 for corners). \n\nThe third array, `CC` stores the location of the corner cubies and the fourth array `EE`, stores the location of edge cubies. The elements of `CC` are values between `0` and `7` and the elements of `EE` are values between `0` and `11`. \n\nThe state can be recovered from the orientations of all the cubies: for example, we know that the edge cubie with label `3` is at the location `EE[3]`, and oriented according to the value stored in `E[3]`.\n\nWhich data structure for representing the state of a Rubik's cube takes up the least space? Assume that we are measuring the space in terms of the total lengths of the sequences involved in each representation.\n\n- the first approach with six 2D arrays\n- the second approach using a linked list\n- the current approach using two cubie arrays\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.5 \nConsider the representation involving cubies described in the previous part.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. How many values would you have to update in the `CC` array?\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.6\nConsider the representation involving cubies described in the previous part.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. How many values would you have to update in the `EE` array?\n:::\n\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 2. Stable Matchings\n\nRecall that the stable matching problem involves N men and N women. Each man has a ranking of all N women and each woman has a ranking of all N men. A matching M is a collection of N pairs where each pair consists of a man and a woman, and all the men and women appear in exactly one pair. A man `a` and a woman `b` are said to _block_ M if `a` prefers `b` over his matched partner in M and `b` prefers `a` over her matched partner in M according to their respective rankings. A matching is _stable_ if there are no blocking pairs with respect to it.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2.1\nSuppose X and Y are two stable matchings. For a man `a`, let `X[a]` denote the matched partner of `a` in the matching `X` and let `Y[a]` denote the matched partner of `a` in the matching `Y`.\n\nConsider a matching Z formed as follows: pair up each man `a` with the woman he prefers _more_ between `X[a]` and `Y[a]`. \n\nNote: If `X[a]` and `Y[a]` happen to be the same woman `b`, then pair `a` with `b`.\n\nWhat can we say about Z?\n\n- Z is not necessarily a matching.\n- Z is a matching but not necessarily stable.\n- Z is always a stable matching.\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2.2\nSuppose X and Y are two stable matchings. For a man `a`, let `X[a]` denote the matched partner of `a` in the matching `X` and let `Y[a]` denote the matched partner of `a` in the matching `Y`.\n\nConsider a matching Z formed as follows: pair up each man `a` with the woman he prefers _less_ between `X[a]` and `Y[a]`. \n\nNote: If `X[a]` and `Y[a]` happen to be the same woman `b`, then pair `a` with `b`.\n\nWhat can we say about Z?\n\n- Z is not necessarily a matching.\n- Z is a matching but not necessarily stable.\n- Z is always a stable matching.\n:::\n\n:::\n\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 3. An Array and A Virus\n\nThe memory of Rubina's computer contains two interesting things: an array of integers and a virus. Each midnight the virus becomes active. It takes each array in memory and _replaces_ it with a bunch of new arrays: one for each contiguous subarray of the original array.\n\nFor example, if today the memory contains a single array `(1,2,1,3)`, tomorrow it will contain the following arrays: `(1), (2), (1), (3), (1,2), (2,1), (1,3), (1,2,1), (2,1,3), (1,2,1,3)`.\n\nAs another example, if today the memory contains a single array `(7,7)`, tomorrow it will contain the following arrays: `(7), (7), (7,7)`, and the day after tomorrow it will contain the following arrays: `(7), (7), (7), (7), (7,7)`, and so on. \n\nYou are given Rubina's original array $A$ and the number of days $D$. Let $f(A,D)$ be the sum of all elements of all arrays that will be in the memory of Rubina's computer after D days. Our goal is to calculate $f(A,D)$. You may assume that the memory of Rubina's computer is sufficiently large to accommodate all the arrays.\n\nFor example, if $A$ is the array `(1,2,1,3)` and $D = 0$ then the answer is `7`.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.1\nIf A = `(1,2,1,3)` and $D = 1$, what is $f(A,D)$?\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 34\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.2\n\nIf $A =$ `(500)` and $D = 120$, what is $f(A,D)$?\n\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 500\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.3 \n\nIf A = `(1,2)` and $D = 10$, what is $f(A,D)$?\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 33\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.4\n\nIf $A$ has four elements, how many arrays of length _one_ are there after two steps? \n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 20\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n\n:::\n\n:::\n\n::: Problem 4. A Bit of a Graph\n\nThe bit strings of length four are given by:\n\n`0000`, `0001`, `0010`, `0011`, `0100`, `0101`, `0110`, `0111`, `1000`, `1001`, `1010`, `1011`, `1100`, `1101`, `1110`, `1111`.\n\nConsider a graph where we have:\n\n- a vertex for every bit string of length _four_, and let us say that the bit string associated with a vertex $u$ is denoted by $b_u$; and\n- an edge from $u$ to $v$ if the corresponding bit strings are such that the last three bits of $b_u$ is the same as the first three bits of $b_v$.\n\nFor example, we will have an edge from the vertex representing `0010` to the vertex representing `0101`. We will also have an edge from the vertex representing `0010` to the vertex representing `0100`. \n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.1\n\nHow many vertices does this graph have?\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.2\n\nHow many edges does this graph have?\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.3\n\nHow many vertices in this graph have a self-loop?\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.4\n\nDoes this graph have a closed Euler Tour?\n\n:::\n\n:::\n\n\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["fontawesome"],"css":["../../../styles.css","/css/teaching.css"],"toc":false,"include-in-header":[{"text":"<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Berkshire+Swash&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap\" rel=\"stylesheet\">\n<link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n<script>\nwindow.addEventListener('load', function() {\n  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')); \n  tooltipTriggerList.forEach(function(element) {\n    new bootstrap.Tooltip(element, {\n      trigger: 'hover',\n      animation: true,\n      delay: { show: 50, hide: 50 }\n    });\n  });\n});\n</script>\n"}],"output-file":"exam01.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo","js":"../../../scripts.js","page-layout":"full","sidebar":false,"title":"ES242. Data Structures and Algorithms I. Exam 01","code-copy":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
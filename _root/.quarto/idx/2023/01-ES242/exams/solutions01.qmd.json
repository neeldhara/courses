{"title":"ES242. Data Structures and Algorithms I. Exam 01 - Solutions","markdown":{"yaml":{"css":"/css/teaching.css","toc":false,"sidebar":false,"title":"ES242. Data Structures and Algorithms I. Exam 01 - Solutions","code-copy":true},"headingText":"ES242. Data Structures and Algorithms I.","containsRefs":false,"markdown":"\n\n:::{.column-body-outset}\n\n\n##### Solutions to Exam 01 \n\nIssued: 16 Feb, 2023\n\n[Back to course page](../index.qmd)\n\n\n\n:::{.callout-caution icon=\"false\"} \n\n# Remark\n\nThe question indices may be different from what you see on Gradescope because of the extra confidence rating questions. Multiply by two and subtract one from the question number to map it to Gradescope :)\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 1. The Rubik's Cube\n\nThe Rubik's Cube is a 3-D combination puzzle involving a cube with a grid of nine squares on each face. In a solved state, each face of the cube has all the nine squares colored using one of six solid colours: white, red, blue, orange, green, and yellow. \n\n![A Rubik Cube](images.jpg)\n\nThe arrangement of colours is now standardised with white opposite yellow, blue opposite green, and orange opposite red, and the red, white, and blue arranged clockwise in that order.\n\nAn internal pivot mechanism enables each face to turn independently, thus mixing up the colours. For the puzzle to be solved, each face must be returned to have only one colour. \n\nSuppose you are implementing a Rubik Cube solver. To answer these questions, you _do not_ need to know how to solve a Rubik's cube. We assume that the cube is in a fixed orientation, so that that we can identify the front, back, top, bottom, left, and right faces in the natural way.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.1 \nOne natural way to store the state of the cube is to use six 3x3 arrays of chars, with each character representing a color: `cube-front[3][3]`, `cube-back[3][3]`, `cube-top[3][3]`, `cube-bottom[3][3]`, `cube-left[3][3]`, `cube-right[3][3]`.\n\nIn this representation, to get the color of the sticker on the top-left corner of the front face, you would check the value of `cube-front[0][0]`. \n\nIn general, for a face `F`, to get the color of the sticker on row `R` and column `C`, you will check the value of `cube-F[R][C]`.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. Which array would remain unchanged?\n\n- `cube-front[3][3]`\n- `cube-back[3][3]`\n- `cube-top[3][3]`\n- `cube-bottom[3][3]`\n- `cube-left[3][3]`\n- `cube-right[3][3]`\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nIf the top face is rotated then the bottom face is the only face that is _certainly_ not affected. The top face itself _may_ not be affected (for example, when all stickers on the top face have the same color), however, this is not guaranteed.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.2 \nConsider the following approach. Instead of storing six separate two-dimensional arrays, we store the state of the cube as a linked list with 54 entries as depicted below, by listing all the elements in the `cube-front` array first, followed by `cube-back`, `cube-top`, `cube-bottom`, `cube-left`, `cube-right`. The elements within a face are listed row-wise (i.e, all elements of the first row are listed first, second row second, and so on).\n\n![Transforming the arrays to a linked list](fromarray-to-ll.png)\n\nSuppose you want to determine the color of a sticker at a particular location, which is specified by the face, row number, and column number. Which approach will require _more_ steps?\n\n- The array approach\n- The linked list approach\n\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nWhile the index of the location in the linked list can be calculated in constant time, since we do not have direct access, the linked list approach will require more steps in the worst case.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.3 \nConsider the linked list approach from the previous question. What is the index of the element that stores the color of the center sticker (i.e, row 1 and column 1 with 0-based indexing) of the bottom face? Assume that the linked list is 1-indexed: for example the index of the element that stores the color of the center sticker for the front face is `5`.\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nThe answer is 32 by direct inspection.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.4 \nObserve that the central pieces of each face in a Rubik's cube do not move with any of the rotations. We can think of the Rubik's cube as being assembled from 8 corner pieces and 12 edge pieces as shown below. Each of these individual pieces is called a _cubie_.\n\n\n![Cubies](cubies.png)\n\nObserve that the state of the cube can be fully specified by specifying the orientation of all the cubies. Fix a labeling of all the corner cubies from `0` to `7` and the edge cubies from `0` to `11`.\n\nIn particular, let us say that we store the state by storing two _orientation_ arrays and two _location_ arrays.\n\nThe first array, `C` stores the orientation of the corner cubies and the second array `E`, stores the orientation of edge cubies. The elements of each array stores an orientation (0 or 1 for edges; 0, 1, or 2 for corners). \n\nThe third array, `CC` stores the location of the corner cubies and the fourth array `EE`, stores the location of edge cubies. The elements of `CC` are values between `0` and `7` and the elements of `EE` are values between `0` and `11`. \n\nThe state can be recovered from the orientations of all the cubies: for example, we know that the edge cubie with label `3` is at the location `EE[3]`, and oriented according to the value stored in `E[3]`.\n\nWhich data structure for representing the state of a Rubik's cube takes up the least space? Assume that we are measuring the space in terms of the total lengths of the sequences involved in each representation.\n\n- the first approach with six 2D arrays\n- the second approach using a linked list\n- the current approach using two cubie arrays\n\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nThe cubie approach requires employing a total of `40` units of memory, which is less than the `54` units we needed in the other two approaches. \n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.5 \nConsider the representation involving cubies described in the previous part.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. How many values would you have to update in the `CC` array?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nSince only four corner cubes are involved in one rotation, the answer is `4`. Note that the set of affected cubies is the same for 90 and 180 degree rotations of the top face.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.6\nConsider the representation involving cubies described in the previous part.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. How many values would you have to update in the `EE` array?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nSince only four edge cubes are involved in one rotation, the answer is `4`. Note that the set of affected cubies is the same for 90 and 180 degree rotations of the top face.\n:::\n\n:::\n\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 2. Stable Matchings\n\nRecall that the stable matching problem involves N men and N women. Each man has a ranking of all N women and each woman has a ranking of all N men. A matching M is a collection of N pairs where each pair consists of a man and a woman, and all the men and women appear in exactly one pair. A man `a` and a woman `b` are said to _block_ M if `a` prefers `b` over his matched partner in M and `b` prefers `a` over her matched partner in M according to their respective rankings. A matching is _stable_ if there are no blocking pairs with respect to it.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2.1\nSuppose X and Y are two stable matchings. For a man `a`, let `X[a]` denote the matched partner of `a` in the matching `X` and let `Y[a]` denote the matched partner of `a` in the matching `Y`.\n\nConsider a matching Z formed as follows: pair up each man `a` with the woman he prefers _more_ between `X[a]` and `Y[a]`. \n\nNote: If `X[a]` and `Y[a]` happen to be the same woman `b`, then pair `a` with `b`.\n\nWhat can we say about Z?\n\n- Z is not necessarily a matching.\n- Z is a matching but not necessarily stable.\n- Z is always a stable matching.\n\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nFirst, let us argue that Z is a matching. Suppose not: this means that some woman appears in more than one pair. Suppose there are two men `p` and `q` who are both matched to a woman `b`. Then `p` and `q` both prefer `b` over their matched partners in the matching where they are _not_ matched to `b`. Now:\n\n- If `b` prefers `p` over `q`, and `p` was matched to `b` in the matching X, then observe that `b` must have been matched to `q` in Y and `(p,b)` is a blocking pair for Y.\n- If `b` prefers `p` over `q`, and `p` was matched to `b` in the matching Y, then observe that `b` must have been matched to `q` in X and `(p,b)` is a blocking pair for X.\n- If `b` prefers `q` over `p`, and `q` was matched to `b` in the matching X, then observe that `b` must have been matched to `p` in Y and `(q,b)` is a blocking pair for Y.\n- If `b` prefers `q` over `p`, and `q` was matched to `b` in the matching Y, then observe that `b` must have been matched to `p` in X and `(q,b)` is a blocking pair for X.\n\nIn all cases, we have a contradiction to the assumption that both X and Y are stable.\n\nSo Z is a matching. We now argue that Z is stable. Suppose not, and let `(a,b)` be a blocking pair in Z, with `a` being the man and `b` being the woman. Further, let the matched partner of `a` in Z be `p` and the matched partner of `b` in Z be `q`. \n\nNote that `b` was matched to `q` in either X or Y. Suppose `b` was matched to `q` in X. In X, `a` is matched either to `p` or someone that `a` prefers less to `p`. Since `a` prefers `b` over `p` (since `(a,b)` is a blocking pair), `a` prefers `b` over his matched partner in X. We already know that `b` prefers `a` over `q` for the same reason. So, `(a,b)` remains a blocking pair in the matching X, which contradicts our assumption that X was stable. \n\nA similar argument holds if `b` was matched to `q` in Y, where we contradict the stability of Y instead.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2.2\nSuppose X and Y are two stable matchings. For a man `a`, let `X[a]` denote the matched partner of `a` in the matching `X` and let `Y[a]` denote the matched partner of `a` in the matching `Y`.\n\nConsider a matching Z formed as follows: pair up each man `a` with the woman he prefers _less_ between `X[a]` and `Y[a]`. \n\nNote: If `X[a]` and `Y[a]` happen to be the same woman `b`, then pair `a` with `b`.\n\nWhat can we say about Z?\n\n- Z is not necessarily a matching.\n- Z is a matching but not necessarily stable.\n- Z is always a stable matching.\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nIt turns out that Z is always a stable matching, the argument is analogous to the previous question.\n:::\n\n:::\n\n:::\n\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 3. An Array and A Virus\n\nThe memory of Rubina's computer contains two interesting things: an array of integers and a virus. Each midnight the virus becomes active. It takes each array in memory and _replaces_ it with a bunch of new arrays: one for each contiguous subarray of the original array.\n\nFor example, if today the memory contains a single array `(1,2,1,3)`, tomorrow it will contain the following arrays: `(1), (2), (1), (3), (1,2), (2,1), (1,3), (1,2,1), (2,1,3), (1,2,1,3)`.\n\nAs another example, if today the memory contains a single array `(7,7)`, tomorrow it will contain the following arrays: `(7), (7), (7,7)`, and the day after tomorrow it will contain the following arrays: `(7), (7), (7), (7), (7,7)`, and so on. \n\nYou are given Rubina's original array $A$ and the number of days $D$. Let $f(A,D)$ be the sum of all elements of all arrays that will be in the memory of Rubina's computer after D days. Our goal is to calculate $f(A,D)$. You may assume that the memory of Rubina's computer is sufficiently large to accommodate all the arrays.\n\nFor example, if $A$ is the array `(1,2,1,3)` and $D = 0$ then the answer is `7`.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.1\nIf A = `(1,2,1,3)` and $D = 1$, what is $f(A,D)$?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n34\n:::\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 34\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.2\n\nIf $A =$ `(500)` and $D = 120$, what is $f(A,D)$?\n\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 500\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n500\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.3 \n\nIf A = `(1,2)` and $D = 10$, what is $f(A,D)$?\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 33\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n33\n:::\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.4\n\nIf $A$ has four elements, how many arrays of length _one_ are there after two steps? \n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n20\n:::\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 20\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n\n:::\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 4. A Bit of a Graph\n\nThe bit strings of length four are given by:\n\n`0000`, `0001`, `0010`, `0011`, `0100`, `0101`, `0110`, `0111`, `1000`, `1001`, `1010`, `1011`, `1100`, `1101`, `1110`, `1111`.\n\nConsider a graph where we have:\n\n- a vertex for every bit string of length _four_, and let us say that the bit string associated with a vertex $u$ is denoted by $b_u$; and\n- an edge from $u$ to $v$ if the corresponding bit strings are such that the last three bits of $b_u$ is the same as the first three bits of $b_v$.\n\nFor example, we will have an edge from the vertex representing `0010` to the vertex representing `0101`. We will also have an edge from the vertex representing `0010` to the vertex representing `0100`. \n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.1\n\nHow many vertices does this graph have?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n16\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.2\n\nHow many edges does this graph have?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n32\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.3\n\nHow many vertices in this graph have a self-loop?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nTwo\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.4\n\nDoes this graph have a closed Euler Tour?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nYes\n:::\n\n:::\n\n:::\n\n\n:::","srcMarkdownNoYaml":"\n\n:::{.column-body-outset}\n\n## ES242. Data Structures and Algorithms I.\n\n##### Solutions to Exam 01 \n\nIssued: 16 Feb, 2023\n\n[Back to course page](../index.qmd)\n\n\n\n:::{.callout-caution icon=\"false\"} \n\n# Remark\n\nThe question indices may be different from what you see on Gradescope because of the extra confidence rating questions. Multiply by two and subtract one from the question number to map it to Gradescope :)\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 1. The Rubik's Cube\n\nThe Rubik's Cube is a 3-D combination puzzle involving a cube with a grid of nine squares on each face. In a solved state, each face of the cube has all the nine squares colored using one of six solid colours: white, red, blue, orange, green, and yellow. \n\n![A Rubik Cube](images.jpg)\n\nThe arrangement of colours is now standardised with white opposite yellow, blue opposite green, and orange opposite red, and the red, white, and blue arranged clockwise in that order.\n\nAn internal pivot mechanism enables each face to turn independently, thus mixing up the colours. For the puzzle to be solved, each face must be returned to have only one colour. \n\nSuppose you are implementing a Rubik Cube solver. To answer these questions, you _do not_ need to know how to solve a Rubik's cube. We assume that the cube is in a fixed orientation, so that that we can identify the front, back, top, bottom, left, and right faces in the natural way.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.1 \nOne natural way to store the state of the cube is to use six 3x3 arrays of chars, with each character representing a color: `cube-front[3][3]`, `cube-back[3][3]`, `cube-top[3][3]`, `cube-bottom[3][3]`, `cube-left[3][3]`, `cube-right[3][3]`.\n\nIn this representation, to get the color of the sticker on the top-left corner of the front face, you would check the value of `cube-front[0][0]`. \n\nIn general, for a face `F`, to get the color of the sticker on row `R` and column `C`, you will check the value of `cube-F[R][C]`.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. Which array would remain unchanged?\n\n- `cube-front[3][3]`\n- `cube-back[3][3]`\n- `cube-top[3][3]`\n- `cube-bottom[3][3]`\n- `cube-left[3][3]`\n- `cube-right[3][3]`\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nIf the top face is rotated then the bottom face is the only face that is _certainly_ not affected. The top face itself _may_ not be affected (for example, when all stickers on the top face have the same color), however, this is not guaranteed.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.2 \nConsider the following approach. Instead of storing six separate two-dimensional arrays, we store the state of the cube as a linked list with 54 entries as depicted below, by listing all the elements in the `cube-front` array first, followed by `cube-back`, `cube-top`, `cube-bottom`, `cube-left`, `cube-right`. The elements within a face are listed row-wise (i.e, all elements of the first row are listed first, second row second, and so on).\n\n![Transforming the arrays to a linked list](fromarray-to-ll.png)\n\nSuppose you want to determine the color of a sticker at a particular location, which is specified by the face, row number, and column number. Which approach will require _more_ steps?\n\n- The array approach\n- The linked list approach\n\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nWhile the index of the location in the linked list can be calculated in constant time, since we do not have direct access, the linked list approach will require more steps in the worst case.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.3 \nConsider the linked list approach from the previous question. What is the index of the element that stores the color of the center sticker (i.e, row 1 and column 1 with 0-based indexing) of the bottom face? Assume that the linked list is 1-indexed: for example the index of the element that stores the color of the center sticker for the front face is `5`.\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nThe answer is 32 by direct inspection.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.4 \nObserve that the central pieces of each face in a Rubik's cube do not move with any of the rotations. We can think of the Rubik's cube as being assembled from 8 corner pieces and 12 edge pieces as shown below. Each of these individual pieces is called a _cubie_.\n\n\n![Cubies](cubies.png)\n\nObserve that the state of the cube can be fully specified by specifying the orientation of all the cubies. Fix a labeling of all the corner cubies from `0` to `7` and the edge cubies from `0` to `11`.\n\nIn particular, let us say that we store the state by storing two _orientation_ arrays and two _location_ arrays.\n\nThe first array, `C` stores the orientation of the corner cubies and the second array `E`, stores the orientation of edge cubies. The elements of each array stores an orientation (0 or 1 for edges; 0, 1, or 2 for corners). \n\nThe third array, `CC` stores the location of the corner cubies and the fourth array `EE`, stores the location of edge cubies. The elements of `CC` are values between `0` and `7` and the elements of `EE` are values between `0` and `11`. \n\nThe state can be recovered from the orientations of all the cubies: for example, we know that the edge cubie with label `3` is at the location `EE[3]`, and oriented according to the value stored in `E[3]`.\n\nWhich data structure for representing the state of a Rubik's cube takes up the least space? Assume that we are measuring the space in terms of the total lengths of the sequences involved in each representation.\n\n- the first approach with six 2D arrays\n- the second approach using a linked list\n- the current approach using two cubie arrays\n\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nThe cubie approach requires employing a total of `40` units of memory, which is less than the `54` units we needed in the other two approaches. \n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.5 \nConsider the representation involving cubies described in the previous part.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. How many values would you have to update in the `CC` array?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nSince only four corner cubes are involved in one rotation, the answer is `4`. Note that the set of affected cubies is the same for 90 and 180 degree rotations of the top face.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 1.6\nConsider the representation involving cubies described in the previous part.\n\nSuppose we have a cube is in some state (not necessarily solved), and we want to transform the state to the one the cube would be in if the top face was rotated clockwise. How many values would you have to update in the `EE` array?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nSince only four edge cubes are involved in one rotation, the answer is `4`. Note that the set of affected cubies is the same for 90 and 180 degree rotations of the top face.\n:::\n\n:::\n\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 2. Stable Matchings\n\nRecall that the stable matching problem involves N men and N women. Each man has a ranking of all N women and each woman has a ranking of all N men. A matching M is a collection of N pairs where each pair consists of a man and a woman, and all the men and women appear in exactly one pair. A man `a` and a woman `b` are said to _block_ M if `a` prefers `b` over his matched partner in M and `b` prefers `a` over her matched partner in M according to their respective rankings. A matching is _stable_ if there are no blocking pairs with respect to it.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2.1\nSuppose X and Y are two stable matchings. For a man `a`, let `X[a]` denote the matched partner of `a` in the matching `X` and let `Y[a]` denote the matched partner of `a` in the matching `Y`.\n\nConsider a matching Z formed as follows: pair up each man `a` with the woman he prefers _more_ between `X[a]` and `Y[a]`. \n\nNote: If `X[a]` and `Y[a]` happen to be the same woman `b`, then pair `a` with `b`.\n\nWhat can we say about Z?\n\n- Z is not necessarily a matching.\n- Z is a matching but not necessarily stable.\n- Z is always a stable matching.\n\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nFirst, let us argue that Z is a matching. Suppose not: this means that some woman appears in more than one pair. Suppose there are two men `p` and `q` who are both matched to a woman `b`. Then `p` and `q` both prefer `b` over their matched partners in the matching where they are _not_ matched to `b`. Now:\n\n- If `b` prefers `p` over `q`, and `p` was matched to `b` in the matching X, then observe that `b` must have been matched to `q` in Y and `(p,b)` is a blocking pair for Y.\n- If `b` prefers `p` over `q`, and `p` was matched to `b` in the matching Y, then observe that `b` must have been matched to `q` in X and `(p,b)` is a blocking pair for X.\n- If `b` prefers `q` over `p`, and `q` was matched to `b` in the matching X, then observe that `b` must have been matched to `p` in Y and `(q,b)` is a blocking pair for Y.\n- If `b` prefers `q` over `p`, and `q` was matched to `b` in the matching Y, then observe that `b` must have been matched to `p` in X and `(q,b)` is a blocking pair for X.\n\nIn all cases, we have a contradiction to the assumption that both X and Y are stable.\n\nSo Z is a matching. We now argue that Z is stable. Suppose not, and let `(a,b)` be a blocking pair in Z, with `a` being the man and `b` being the woman. Further, let the matched partner of `a` in Z be `p` and the matched partner of `b` in Z be `q`. \n\nNote that `b` was matched to `q` in either X or Y. Suppose `b` was matched to `q` in X. In X, `a` is matched either to `p` or someone that `a` prefers less to `p`. Since `a` prefers `b` over `p` (since `(a,b)` is a blocking pair), `a` prefers `b` over his matched partner in X. We already know that `b` prefers `a` over `q` for the same reason. So, `(a,b)` remains a blocking pair in the matching X, which contradicts our assumption that X was stable. \n\nA similar argument holds if `b` was matched to `q` in Y, where we contradict the stability of Y instead.\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 2.2\nSuppose X and Y are two stable matchings. For a man `a`, let `X[a]` denote the matched partner of `a` in the matching `X` and let `Y[a]` denote the matched partner of `a` in the matching `Y`.\n\nConsider a matching Z formed as follows: pair up each man `a` with the woman he prefers _less_ between `X[a]` and `Y[a]`. \n\nNote: If `X[a]` and `Y[a]` happen to be the same woman `b`, then pair `a` with `b`.\n\nWhat can we say about Z?\n\n- Z is not necessarily a matching.\n- Z is a matching but not necessarily stable.\n- Z is always a stable matching.\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nIt turns out that Z is always a stable matching, the argument is analogous to the previous question.\n:::\n\n:::\n\n:::\n\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 3. An Array and A Virus\n\nThe memory of Rubina's computer contains two interesting things: an array of integers and a virus. Each midnight the virus becomes active. It takes each array in memory and _replaces_ it with a bunch of new arrays: one for each contiguous subarray of the original array.\n\nFor example, if today the memory contains a single array `(1,2,1,3)`, tomorrow it will contain the following arrays: `(1), (2), (1), (3), (1,2), (2,1), (1,3), (1,2,1), (2,1,3), (1,2,1,3)`.\n\nAs another example, if today the memory contains a single array `(7,7)`, tomorrow it will contain the following arrays: `(7), (7), (7,7)`, and the day after tomorrow it will contain the following arrays: `(7), (7), (7), (7), (7,7)`, and so on. \n\nYou are given Rubina's original array $A$ and the number of days $D$. Let $f(A,D)$ be the sum of all elements of all arrays that will be in the memory of Rubina's computer after D days. Our goal is to calculate $f(A,D)$. You may assume that the memory of Rubina's computer is sufficiently large to accommodate all the arrays.\n\nFor example, if $A$ is the array `(1,2,1,3)` and $D = 0$ then the answer is `7`.\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.1\nIf A = `(1,2,1,3)` and $D = 1$, what is $f(A,D)$?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n34\n:::\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 34\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.2\n\nIf $A =$ `(500)` and $D = 120$, what is $f(A,D)$?\n\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 500\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n500\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.3 \n\nIf A = `(1,2)` and $D = 10$, what is $f(A,D)$?\n\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 33\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n33\n:::\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 3.4\n\nIf $A$ has four elements, how many arrays of length _one_ are there after two steps? \n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n20\n:::\n<!-- \\begin{explanation}\n\t\\begin{mybox}\n\tCorrect answer(s): 20\n\t\\tcblower\n\tBy simulation.\n\t\\end{mybox}\n\\end{explanation} -->\n\n\n:::\n:::\n\n:::{.callout-note icon=\"false\"}\n\n# Problem 4. A Bit of a Graph\n\nThe bit strings of length four are given by:\n\n`0000`, `0001`, `0010`, `0011`, `0100`, `0101`, `0110`, `0111`, `1000`, `1001`, `1010`, `1011`, `1100`, `1101`, `1110`, `1111`.\n\nConsider a graph where we have:\n\n- a vertex for every bit string of length _four_, and let us say that the bit string associated with a vertex $u$ is denoted by $b_u$; and\n- an edge from $u$ to $v$ if the corresponding bit strings are such that the last three bits of $b_u$ is the same as the first three bits of $b_v$.\n\nFor example, we will have an edge from the vertex representing `0010` to the vertex representing `0101`. We will also have an edge from the vertex representing `0010` to the vertex representing `0100`. \n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.1\n\nHow many vertices does this graph have?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n16\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.2\n\nHow many edges does this graph have?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\n32\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.3\n\nHow many vertices in this graph have a self-loop?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nTwo\n:::\n\n:::\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Problem 4.4\n\nDoes this graph have a closed Euler Tour?\n\n:::{.callout-tip icon=\"false\" collapse=\"true\"}\n\n# Answer\n\nYes\n:::\n\n:::\n\n:::\n\n\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["fontawesome"],"css":["../../../styles.css","/css/teaching.css"],"toc":false,"include-in-header":[{"text":"<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Berkshire+Swash&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap\" rel=\"stylesheet\">\n<link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n<script>\nwindow.addEventListener('load', function() {\n  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')); \n  tooltipTriggerList.forEach(function(element) {\n    new bootstrap.Tooltip(element, {\n      trigger: 'hover',\n      animation: true,\n      delay: { show: 50, hide: 50 }\n    });\n  });\n});\n</script>\n"}],"output-file":"solutions01.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo","js":"../../../scripts.js","page-layout":"full","sidebar":false,"title":"ES242. Data Structures and Algorithms I. Exam 01 - Solutions","code-copy":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
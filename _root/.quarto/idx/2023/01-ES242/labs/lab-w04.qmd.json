{"title":"ES242. Data Structures and Algorithms I. Week 04 Lab","markdown":{"yaml":{"css":"/css/teaching.css","toc":false,"sidebar":false,"title":"ES242. Data Structures and Algorithms I. Week 04 Lab","code-copy":true},"headingText":"ES242. Data Structures and Algorithms I.","containsRefs":false,"markdown":"\n\n:::{.column-body-outset}\n\n\n##### Lab 04\n\n[Back to course page](../index.qmd)\n\n:::{.callout-warning appearance=\"minimal\"}\nTheme: Graph Representations and Euler Tours\n:::\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 1. Adjacency Matrix\n\nThe goal of this exercise is to:\n\n1. Read a graph and store it as an adjacency matrix.\n2. Return the largest degree, that is to say, return max(d(v)) over all vertices v in the graph G.\n\n<br>\n\nYou can visualize the execution of a simplified version of the template code [here](https://pythontutor.com/render.html#code=//%20Adjacency%20Matrix%20representation%20in%20C%0A%0A%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20int%20n%20%3D%206%3B%0A%20%20int%20m%20%3D%204%3B%0A%20%20%0A%20%20int%20G%5B6%5D%5B6%5D%3B%0A%20%20%0A%20%20//%20Initialize%20array%20to%200%3A%0A%20%20for%20%28int%20i%20%3D%200%3B%20i%20%3C%20n%3B%20i%2B%2B%29%0A%20%20%20%20for%20%28int%20j%20%3D%200%3B%20j%20%3C%20n%3B%20j%2B%2B%29%0A%20%20%20%20%20%20G%5Bi%5D%5Bj%5D%20%3D%200%3B%0A%20%20%0A%20%20int%20edges%5B4%5D%5B2%5D%20%3D%20%7B%7B1,2%7D,%7B2,3%7D,%7B3,4%7D,%7B1,5%7D%7D%3B%0A%20%20%0A%20%20//%20Populate%20array%20with%20edges%3A%0A%20%20for%28int%20k%20%3D%200%3B%20k%20%3C%20m%3B%20k%2B%2B%29%7B%0A%20%20%20%20%0A%20%20%20%20int%20u,v%3B%0A%20%20%20%20u%20%3D%20edges%5Bk%5D%5B0%5D%3B%0A%20%20%20%20v%20%3D%20edges%5Bk%5D%5B1%5D%3B%0A%20%20%20%20%0A%20%20%20%20G%5Bu%5D%5Bv%5D%20%3D%201%3B%0A%20%20%20%20G%5Bv%5D%5Bu%5D%20%3D%201%3B%0A%20%20%7D%0A%20%20%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false).\n\n### Input\n\nThe first line of input is two space-separated integers `n` and `m`, denoting the number of vertices and edges of `G`, respectively. Vertices are indexed from `0` to `n-1`.\n\nThe next `m` lines of code are two space separated integers `u` and `v` in the range `0` and `n-1`, indicating an (undirected) edge between vertices `u` and `v`.\n\n### Output\n\nThe output is a single integer, corresponding to the maximum degree of the graph.\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n5 4\n0 1\n0 2\n0 3\n0 4\n```\n\n`Sample Output`\n\n```default\n4\n```\n\n### Template Code\n\n```C\n// Adjacency Matrix representation in C\n#include <stdio.h>\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  int m;\n  scanf(\"%d\", &m);\n\n  int G[n][n];\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      G[i][j] = 0;\n\n  for (int i = 0; i < m; i++) {\n    // Write the logic to read the endpoints of the edge here.\n    // ...\n    \n    // Write the logic to add the edge just read next.\n    // ...\n  }\n\n  int maxdegree = 0;\n\n  // Write the logic to print the maxdegree of the graph here.\n  // ...\n\n  printf(\"%d\", maxdegree);\n  return 0;\n\n}\n```\n\n:::\n\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 2. Adjacency List\n\n\nIn this exercise your goal is to implement a graph as an adjacency list and determine, given a pair of vertices `u` and `v`, the number of common nieghbors that they have: that is, the number of vertices `w` such that `w` is adjacent to `u` AND `w` is adjacent to `v` (note that `w` is _not_ equal to either `u` or `v`).\n\nYou can visualize the execution of a simplified version of the template code [here](https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%23include%20%3Cstdlib.h%3E%0A%0A//%20A%20structure%20to%20represent%20an%20adjacency%20list%20node%0Astruct%20AdjListNode%20%7B%0A%20%20int%20vertex%3B%0A%20%20struct%20AdjListNode%20*next%3B%0A%7D%3B%0A%0A//%20A%20structure%20to%20represent%20a%20graph.%20A%20graph%20is%20an%20array%20of%20adjacency%20lists.%0A//%20Size%20of%20array%20will%20be%20V%20%28number%20of%20vertices%20in%20graph%29%0Astruct%20Graph%20%7B%0A%20%20int%20n%3B%0A%20%20struct%20AdjListNode*%20vertices%3B%0A%7D%3B%0A%0A//%20A%20utility%20function%20to%20create%20a%20new%20adjacency%20list%20node%0Astruct%20AdjListNode*%20newAdjListNode%28int%20v%29%20%7B%0A%20%20struct%20AdjListNode%20*newNode%20%3D%0A%20%20%20%20%20%20%28struct%20AdjListNode%20*%29malloc%28sizeof%28struct%20AdjListNode%29%29%3B%0A%20%20newNode-%3Evertex%20%3D%20v%3B%0A%20%20newNode-%3Enext%20%3D%20NULL%3B%0A%20%20return%20newNode%3B%0A%7D%0A%0A//%20A%20utility%20function%20that%20creates%20a%20graph%20of%20V%20vertices%0Astruct%20Graph%20*createGraph%28int%20V%29%20%7B%0A%20%20struct%20Graph%20*graph%20%3D%20%28struct%20Graph*%29malloc%28sizeof%28struct%20Graph%29%29%3B%0A%20%20graph-%3En%20%3D%20V%3B%0A%20%20%0A%20%20graph-%3Evertices%20%3D%20%28struct%20AdjListNode*%29%20malloc%28V%20*%20sizeof%28struct%20AdjListNode%29%29%3B%0A%20%20int%20i%3B%0A%20%20for%20%28i%20%3D%200%3B%20i%20%3C%20V%3B%20%2B%2Bi%29%7B%0A%20%20%20%20graph-%3Evertices%5Bi%5D.next%20%3D%20NULL%3B%0A%20%20%20%20graph-%3Evertices%5Bi%5D.vertex%20%3D%20-1%3B%0A%20%20%7D%0A%0A%20%20return%20graph%3B%0A%7D%0A%0A//%20Adds%20an%20edge%20to%20an%20undirected%20graph%0Avoid%20addEdge%28struct%20Graph%20*graph,%20int%20src,%20int%20dest%29%20%7B%0A%20%20//%20Add%20an%20edge%20from%20src%20to%20dest.%20%20A%20new%20node%20is%20added%20to%20the%20adjacency%0A%20%20//%20list%20of%20src.%20%20The%20node%20is%20added%20at%20the%20begining%0A%20%20struct%20AdjListNode%20*newNode%20%3D%20newAdjListNode%28dest%29%3B%0A%20%20%0A%20%20newNode-%3Enext%20%3D%20graph-%3Evertices%5Bsrc%5D.next%3B%0A%20%20graph-%3Evertices%5Bsrc%5D.next%20%3D%20newNode%3B%0A%0A%20%20//%20Since%20graph%20is%20undirected,%20add%20an%20edge%20from%20dest%20to%20src%20also%0A%20%20newNode%20%3D%20newAdjListNode%28src%29%3B%0A%20%20newNode-%3Enext%20%3D%20graph-%3Evertices%5Bdest%5D.next%3B%0A%20%20graph-%3Evertices%5Bdest%5D.next%20%3D%20newNode%3B%0A%7D%0A%0Aint%20main%28%29%20%7B%0A%20%20struct%20Graph%20*G%20%3D%20createGraph%285%29%3B%0A%0A%20%20for%20%28int%20i%20%3D%201%3B%20i%20%3C%205%3B%20i%2B%2B%29%20%7B%0A%20%20%20%20addEdge%28G,%200,%20i%29%3B%0A%20%20%7D%0A%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false).\n\n### Input\n\n\nThe first line of input is two space-separated integers `n` and `m`, denoting the number of vertices and edges of `G`, respectively. Vertices are indexed from `0` to `n-1`.\n\nThe next `m` lines of code are two space separated integers `u` and `v` in the range `0` and `n-1`, indicating an (undirected) edge between vertices `u` and `v`.\n\nThe last line is a pair of space-separated integers `x` and `y`.\n\n### Output\n\nThe output is a single integer, corresponding to the number of common neighbors of `x` and `y`.\n\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n6 8\n0 1\n0 2\n0 3\n0 4\n5 1\n5 2\n5 3\n5 4\n0 5\n```\n\n`Sample Output`\n\n```default\n4\n```\n\n### Template Code\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\n// A structure to represent an adjacency list node\nstruct AdjListNode {\n  int vertex;\n  struct AdjListNode *next;\n};\n\n// A structure to represent a graph. A graph is an array of adjacency lists.\n// Size of array will be V (number of vertices in graph)\nstruct Graph {\n  int n;\n  struct AdjListNode* vertices;\n};\n\n// A utility function to create a new adjacency list node\nstruct AdjListNode* newAdjListNode(int v) {\n  struct AdjListNode *newNode =\n      (struct AdjListNode *)malloc(sizeof(struct AdjListNode));\n  newNode->vertex = v;\n  newNode->next = NULL;\n  return newNode;\n}\n\n// A utility function that creates a graph of V vertices\nstruct Graph *createGraph(int V) {\n  struct Graph *graph = (struct Graph*)malloc(sizeof(struct Graph));\n  graph->n = V;\n  \n  graph->vertices = (struct AdjListNode*) malloc(V * sizeof(struct AdjListNode));\n  int i;\n  for (i = 0; i < V; ++i){\n    graph->vertices[i].next = NULL;\n    graph->vertices[i].vertex = -1;\n  }\n\n  return graph;\n}\n\n// Adds an edge to an undirected graph\nvoid addEdge(struct Graph *graph, int src, int dest) {\n  // Add an edge from src to dest.  A new node is added to the adjacency\n  // list of src.  The node is added at the begining\n  struct AdjListNode *newNode = newAdjListNode(dest);\n  newNode->next = graph->vertices[src].next;\n  graph->vertices[src].next = newNode;\n\n  // Since graph is undirected, add an edge from dest to src also. Write this part below.\n  // ...\n}\n\nint main() {\n\n  int n;\n  scanf(\"%d\", &n);\n\n  struct Graph *G = createGraph(n);\n\n  int m;\n  scanf(\"%d\", &m);\n\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d\", &u);\n    scanf(\"%d\", &v);\n    addEdge(G, u, v);\n  }\n\n  int x, y;\n  \n  scanf(\"%d %d\", &x, &y);\n\n  // Write your solution here.\n  \n  return 0;\n}\n```\n\n:::\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 3. Edge List\n\n\nYou have to store the edges of a given graph as an edge list, and compute the degree of a given vertex.\n\nFor understanding how the template code works [refer to this execution](https://pythontutor.com/visualize.html#code=%23include%20%3Cstdio.h%3E%0A%0A//%20Declare%20a%20datatype%20that%20stores%20a%20single%20edge.%0A%0Astruct%20SingleEdge%7B%0A%20%20int%20ep%5B2%5D%3B%0A%20%20struct%20SingleEdge*%20nextedge%3B%0A%7D%3B%0A%0A%0A%0Aint%20main%28void%29%20%7B%0A%0A%20%20//%20To%20begin%20with,%20there%20was%20nothing.%0A%0A%20%20%0A%20%20struct%20SingleEdge*%20head%20%3D%20NULL%3B%0A%0A%20%20head%20%3D%20%28struct%20SingleEdge*%29malloc%28sizeof%28struct%20SingleEdge%29%29%3B%20%0A%20%20%20%20%0A%20%20struct%20SingleEdge*%20current%20%3D%20NULL%3B%0A%0A%20%20current%20%3D%20%28struct%20SingleEdge*%29malloc%28sizeof%28struct%20SingleEdge%29%29%3B%0A%0A%20%20%0A%20%20head-%3Eep%5B0%5D%20%3D%20-1%3B%0A%20%20head-%3Eep%5B1%5D%20%3D%20-1%3B%0A%0A%20%20//%20Read%20the%20number%20of%20edges.%0A%20%20%0A%20%20int%20edgelist%5B3%5D%5B2%5D%20%3D%20%7B%7B1,2%7D,%7B2,3%7D,%7B3,4%7D%7D%3B%0A%0A%20%20for%28int%20i%20%3D%200%3B%20i%20%3C%203%3B%20i%2B%2B%29%7B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20struct%20SingleEdge*%20newedge%3B%0A%20%20%20%20%0A%20%20%20%20newedge%20%3D%20%28struct%20SingleEdge*%29malloc%28sizeof%28struct%20SingleEdge%29%29%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20newedge-%3Eep%5B0%5D%20%3D%20edgelist%5Bi%5D%5B0%5D%3B%0A%20%20%20%20newedge-%3Eep%5B1%5D%20%3D%20edgelist%5Bi%5D%5B1%5D%3B%0A%20%20%20%20newedge-%3Enextedge%20%3D%20NULL%3B%0A%20%20%20%20%0A%20%20%20%20current-%3Enextedge%20%3D%20newedge%3B%20%20%20%20%0A%20%20%20%20current%20%3D%20newedge%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20if%28i%20%3D%3D%200%29%7B%0A%20%20%20%20%20%20head-%3Enextedge%20%3D%20current%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20return%200%3B%0A%7D&cumulative=false&heapPrimitives=nevernest&mode=edit&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false) on a hard-coded example.\n\n### Input\n\nThe first line contains a number `m`, which is the number of edges in the graph G.\n\nThe next `m` lines contain two space-separated integers represnting the endpoints of the edges.\n\nThe last line contains a single integer `k`.\n\n### Output\n\nThe task is to report the degree of the vertex `k`, that is, the number of edges for which `k` is one of the endpoints.\n\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n6\n1 3\n2 1\n5 3\n1 7\n1 8\n2 5\n1\n```\n  \n`Sample Output`\n\n```default\n4\n```\n\n### Template Code\n\n```C\n#include <stdio.h>\n\n// Declare a datatype that stores a single edge.\n\nstruct SingleEdge {\n  int ep[2];\n  struct SingleEdge *nextedge;\n};\n\nint main(void) {\n\n  // To begin with, there was nothing.\n  struct SingleEdge *head = NULL;\n  head = (struct SingleEdge *)malloc(sizeof(struct SingleEdge));\n\n  struct SingleEdge *current = NULL;\n  current = (struct SingleEdge *)malloc(sizeof(struct SingleEdge));\n\n  // head simply points to the first element of the list.\n  // current will move forward as things get added.\n\n  head->ep[0] = -1;\n  head->ep[1] = -1;\n  head->nextedge = current;\n\n  // Read the number of edges.\n\n  int m;\n  scanf(\"%d\", &m);\n\n  for (int i = 0; i < m; i++) {\n\n    struct SingleEdge *newedge;\n\n    newedge = (struct SingleEdge *)malloc(sizeof(struct SingleEdge));\n\n    // Populate the newedge struct\n    // with information about the current edge.\n\n    current->nextedge = newedge;\n    current = newedge;\n  }\n\n  struct SingleEdge *navigator = head->nextedge;\n  int degree = 0;\n  int vertex;\n\n  scanf(\"%d\", &vertex);\n\n  while (navigator) {\n    // CHECK IF \"vertex\" is an endpoint\n    // of the current edge being explored.\n    if (...) {\n      degree = degree + 1;\n    }\n    navigator = navigator->nextedge;\n  }\n\n  printf(\"%d\", degree);\n\n  return 0;\n}\n```\n\n:::\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 4. Sanity Check\n\nGiven a simple (no selfloops or multiedges), **connected** (any two vertices are reachable from each other), and undirected (no edge orientations) graph as input, return YES if it has a Euler path OR circuit, and NO otherwise.\n\nYou may assume the following:\n\n- An undirected graph has an Eulerian cycle if and only if every vertex has even degree, and all of its vertices with nonzero degree belong to a single connected component.\n\n- An undirected graph has an Eulerian path if and only if exactly zero or two vertices have odd degree, and all of its vertices with nonzero degree belong to a single connected component.\n\n\n### Input\n\nThe first line of input is two space-separated integers `n` and `m`, denoting the number of vertices and edges of `G`, respectively. Vertices are indexed from `0` to `n-1`.\n\nThe next `m` lines of code are two space separated integers `u` and `v` in the range `0` and `n-1`, indicating an (undirected) edge between vertices `u` and `v`.\n\n\n### Output\n\nOutput YES if it has a Euler path or circuit, and NO otherwise.\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n10 6\n1 3\n2 1\n5 3\n1 7\n1 8\n2 5\n```\n\n`Sample Output`\n\n```default\nYES\n```\n\n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 5. [Optional] Which Way is the Highway?\n\nImagine a grid country with nm axis-parallel highways (no kidding: check out this [video](https://www.youtube.com/watch?v=8Fn_30AD7Pk) about the U.S. interstate highway numbering system! - watching the video is not required for understanding this problem).\n\nOf these highways, $n$ are east-west and m are north-south. Note that the highways form an $(n - 1) \\times (m - 1)$ grid. In order to control the traffic, a policy was enforced which involved making each highway one way.\n\nThis means in each east-west highway, the traffic moves from \"left to right\" or \"right to left\". Also, traffic moves \"top to bottom\" or \"bottom to top\" in each highway that runs north-south. It is possible to enter a horizontal highway from a vertical highway, or vice versa, at their intersection.\n\nA proposed set of orientations is given to you. You have to figure out if it is possible, after making the highways one-way based on these suggested orientations, if it is possible to reach any intersection from any other (without breaking traffic rules!)\n\n### Input\n\nThe first line of input contains two integers $n$ and $m$, denoting the number of east-west highways and the number of north-south highways.\n\nThe second line contains a string of length $n$, made of characters '{' and '}', denoting direction of each horizontal highway. If the i-th character is equal to '{', the highway is directed from right to left otherwise, the highway is directed from left to right. Highways are listed in order from top to bottom.\n\nThe third line contains a string of length m, made of characters 'B' and 'T', denoting direction of each vertical highway. If the i-th character is equal to 'T', the highway is directed from south to north (towards the top), and if it is 'B' the highway is directed from north to south (towards the bottom). Highways are listed in order from left to right.\n\n### Output\n\nIf the given pattern meets the mayor's criteria, print a single line containing \"YES\", otherwise print a single line containing \"NO\".\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n3 3\n}{}\nBTB\n```\n\n`Sample Output`\n\n```default\nNO\n```\n\n`Sample Input`\n\n```default\n4 6\n{}{}\nBTBTBT\n```\n\n`Sample Output`\n\n```default\nYES\n```\n\n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 6. [Optional] Edge Orientation Puzzle\n\n\nLet's say that a vertex in a directed graph is _balanced_ if its indegree is the same as its outdegree.\n\nYou are given a simple and undirected graph $G$. An orientation of $G$ is an assigment of a direction to every edge in $G$. \n\nYou want to come up with an orientation that maximizes the number of balanced vertices. \n\nReturn the number of balanced vertices in a orientation that maximizes this number.\n\n### Input\n\nThe first line contains a positive integer $t~(1 \\leqslant t \\leqslant 200)$ — the number of testsets in the input.\n\nEach of the testsets is given in the following way. \n\nThe first line contains two integers $n$ and $m$ $(1 \\leqslant n \\leqslant 200, 0 \\leqslant m \\leqslant n·(n - 1) / 2)$ — the number of vertices and the number of edges in $G$.\n\nThe next m lines contain the description of the edges. Each line contains two integers $u$ and $v$ $(1 \\leqslant u, v \\leqslant n)$ — the endpoints of the edge. It's guaranteed that there are no self-loops and multiedges. It is possible that the graph is not connected.\n\n### Output\n\nFor each testset print the number of balanced vertices in an orientation that maximizes the number of balanced vertices.\n\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n2\n5 5\n2 1\n4 5\n2 3\n1 3\n3 5\n7 2\n3 7\n4 2\n```\n\n`Sample Output`\n\n```default\n3\n3\n```\n\n\nHere is an orientation of the first graph that has three balanced vertices:\n\n```default\n1 3\n3 5\n5 4\n3 2\n2 1\n```\n\nIn the second graph, no matter how the two edges are oriented, there will be four imbalanced and three balanced vertices.\n\n\n:::\n\n\n## List of Practice Problems\n\n1. [Weird Journey](https://codeforces.com/contest/789/problem/D) - if you already know how to check if a graph is connected, go for this! Otherwise you could come back to it after learning BFS/DFS :)\n2. [ROOKPATH](https://www.codechef.com/problems/ROOKPATH) - can you figure out how to model this problem as finding an Euler Tour?\n3. [Mashtali: a Space Oddysey](https://codeforces.com/contest/1610/problem/F) - at least one method of solving this question involves constructing an Euler tour (but it is less direct than the previous problem), revisit it once you have figured out how to.\n:::","srcMarkdownNoYaml":"\n\n:::{.column-body-outset}\n\n## ES242. Data Structures and Algorithms I.\n\n##### Lab 04\n\n[Back to course page](../index.qmd)\n\n:::{.callout-warning appearance=\"minimal\"}\nTheme: Graph Representations and Euler Tours\n:::\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 1. Adjacency Matrix\n\nThe goal of this exercise is to:\n\n1. Read a graph and store it as an adjacency matrix.\n2. Return the largest degree, that is to say, return max(d(v)) over all vertices v in the graph G.\n\n<br>\n\nYou can visualize the execution of a simplified version of the template code [here](https://pythontutor.com/render.html#code=//%20Adjacency%20Matrix%20representation%20in%20C%0A%0A%23include%20%3Cstdio.h%3E%0A%0Aint%20main%28%29%20%7B%0A%20%20int%20n%20%3D%206%3B%0A%20%20int%20m%20%3D%204%3B%0A%20%20%0A%20%20int%20G%5B6%5D%5B6%5D%3B%0A%20%20%0A%20%20//%20Initialize%20array%20to%200%3A%0A%20%20for%20%28int%20i%20%3D%200%3B%20i%20%3C%20n%3B%20i%2B%2B%29%0A%20%20%20%20for%20%28int%20j%20%3D%200%3B%20j%20%3C%20n%3B%20j%2B%2B%29%0A%20%20%20%20%20%20G%5Bi%5D%5Bj%5D%20%3D%200%3B%0A%20%20%0A%20%20int%20edges%5B4%5D%5B2%5D%20%3D%20%7B%7B1,2%7D,%7B2,3%7D,%7B3,4%7D,%7B1,5%7D%7D%3B%0A%20%20%0A%20%20//%20Populate%20array%20with%20edges%3A%0A%20%20for%28int%20k%20%3D%200%3B%20k%20%3C%20m%3B%20k%2B%2B%29%7B%0A%20%20%20%20%0A%20%20%20%20int%20u,v%3B%0A%20%20%20%20u%20%3D%20edges%5Bk%5D%5B0%5D%3B%0A%20%20%20%20v%20%3D%20edges%5Bk%5D%5B1%5D%3B%0A%20%20%20%20%0A%20%20%20%20G%5Bu%5D%5Bv%5D%20%3D%201%3B%0A%20%20%20%20G%5Bv%5D%5Bu%5D%20%3D%201%3B%0A%20%20%7D%0A%20%20%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false).\n\n### Input\n\nThe first line of input is two space-separated integers `n` and `m`, denoting the number of vertices and edges of `G`, respectively. Vertices are indexed from `0` to `n-1`.\n\nThe next `m` lines of code are two space separated integers `u` and `v` in the range `0` and `n-1`, indicating an (undirected) edge between vertices `u` and `v`.\n\n### Output\n\nThe output is a single integer, corresponding to the maximum degree of the graph.\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n5 4\n0 1\n0 2\n0 3\n0 4\n```\n\n`Sample Output`\n\n```default\n4\n```\n\n### Template Code\n\n```C\n// Adjacency Matrix representation in C\n#include <stdio.h>\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  int m;\n  scanf(\"%d\", &m);\n\n  int G[n][n];\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      G[i][j] = 0;\n\n  for (int i = 0; i < m; i++) {\n    // Write the logic to read the endpoints of the edge here.\n    // ...\n    \n    // Write the logic to add the edge just read next.\n    // ...\n  }\n\n  int maxdegree = 0;\n\n  // Write the logic to print the maxdegree of the graph here.\n  // ...\n\n  printf(\"%d\", maxdegree);\n  return 0;\n\n}\n```\n\n:::\n\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 2. Adjacency List\n\n\nIn this exercise your goal is to implement a graph as an adjacency list and determine, given a pair of vertices `u` and `v`, the number of common nieghbors that they have: that is, the number of vertices `w` such that `w` is adjacent to `u` AND `w` is adjacent to `v` (note that `w` is _not_ equal to either `u` or `v`).\n\nYou can visualize the execution of a simplified version of the template code [here](https://pythontutor.com/render.html#code=%23include%20%3Cstdio.h%3E%0A%23include%20%3Cstdlib.h%3E%0A%0A//%20A%20structure%20to%20represent%20an%20adjacency%20list%20node%0Astruct%20AdjListNode%20%7B%0A%20%20int%20vertex%3B%0A%20%20struct%20AdjListNode%20*next%3B%0A%7D%3B%0A%0A//%20A%20structure%20to%20represent%20a%20graph.%20A%20graph%20is%20an%20array%20of%20adjacency%20lists.%0A//%20Size%20of%20array%20will%20be%20V%20%28number%20of%20vertices%20in%20graph%29%0Astruct%20Graph%20%7B%0A%20%20int%20n%3B%0A%20%20struct%20AdjListNode*%20vertices%3B%0A%7D%3B%0A%0A//%20A%20utility%20function%20to%20create%20a%20new%20adjacency%20list%20node%0Astruct%20AdjListNode*%20newAdjListNode%28int%20v%29%20%7B%0A%20%20struct%20AdjListNode%20*newNode%20%3D%0A%20%20%20%20%20%20%28struct%20AdjListNode%20*%29malloc%28sizeof%28struct%20AdjListNode%29%29%3B%0A%20%20newNode-%3Evertex%20%3D%20v%3B%0A%20%20newNode-%3Enext%20%3D%20NULL%3B%0A%20%20return%20newNode%3B%0A%7D%0A%0A//%20A%20utility%20function%20that%20creates%20a%20graph%20of%20V%20vertices%0Astruct%20Graph%20*createGraph%28int%20V%29%20%7B%0A%20%20struct%20Graph%20*graph%20%3D%20%28struct%20Graph*%29malloc%28sizeof%28struct%20Graph%29%29%3B%0A%20%20graph-%3En%20%3D%20V%3B%0A%20%20%0A%20%20graph-%3Evertices%20%3D%20%28struct%20AdjListNode*%29%20malloc%28V%20*%20sizeof%28struct%20AdjListNode%29%29%3B%0A%20%20int%20i%3B%0A%20%20for%20%28i%20%3D%200%3B%20i%20%3C%20V%3B%20%2B%2Bi%29%7B%0A%20%20%20%20graph-%3Evertices%5Bi%5D.next%20%3D%20NULL%3B%0A%20%20%20%20graph-%3Evertices%5Bi%5D.vertex%20%3D%20-1%3B%0A%20%20%7D%0A%0A%20%20return%20graph%3B%0A%7D%0A%0A//%20Adds%20an%20edge%20to%20an%20undirected%20graph%0Avoid%20addEdge%28struct%20Graph%20*graph,%20int%20src,%20int%20dest%29%20%7B%0A%20%20//%20Add%20an%20edge%20from%20src%20to%20dest.%20%20A%20new%20node%20is%20added%20to%20the%20adjacency%0A%20%20//%20list%20of%20src.%20%20The%20node%20is%20added%20at%20the%20begining%0A%20%20struct%20AdjListNode%20*newNode%20%3D%20newAdjListNode%28dest%29%3B%0A%20%20%0A%20%20newNode-%3Enext%20%3D%20graph-%3Evertices%5Bsrc%5D.next%3B%0A%20%20graph-%3Evertices%5Bsrc%5D.next%20%3D%20newNode%3B%0A%0A%20%20//%20Since%20graph%20is%20undirected,%20add%20an%20edge%20from%20dest%20to%20src%20also%0A%20%20newNode%20%3D%20newAdjListNode%28src%29%3B%0A%20%20newNode-%3Enext%20%3D%20graph-%3Evertices%5Bdest%5D.next%3B%0A%20%20graph-%3Evertices%5Bdest%5D.next%20%3D%20newNode%3B%0A%7D%0A%0Aint%20main%28%29%20%7B%0A%20%20struct%20Graph%20*G%20%3D%20createGraph%285%29%3B%0A%0A%20%20for%20%28int%20i%20%3D%201%3B%20i%20%3C%205%3B%20i%2B%2B%29%20%7B%0A%20%20%20%20addEdge%28G,%200,%20i%29%3B%0A%20%20%7D%0A%0A%20%20return%200%3B%0A%7D&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false).\n\n### Input\n\n\nThe first line of input is two space-separated integers `n` and `m`, denoting the number of vertices and edges of `G`, respectively. Vertices are indexed from `0` to `n-1`.\n\nThe next `m` lines of code are two space separated integers `u` and `v` in the range `0` and `n-1`, indicating an (undirected) edge between vertices `u` and `v`.\n\nThe last line is a pair of space-separated integers `x` and `y`.\n\n### Output\n\nThe output is a single integer, corresponding to the number of common neighbors of `x` and `y`.\n\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n6 8\n0 1\n0 2\n0 3\n0 4\n5 1\n5 2\n5 3\n5 4\n0 5\n```\n\n`Sample Output`\n\n```default\n4\n```\n\n### Template Code\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\n// A structure to represent an adjacency list node\nstruct AdjListNode {\n  int vertex;\n  struct AdjListNode *next;\n};\n\n// A structure to represent a graph. A graph is an array of adjacency lists.\n// Size of array will be V (number of vertices in graph)\nstruct Graph {\n  int n;\n  struct AdjListNode* vertices;\n};\n\n// A utility function to create a new adjacency list node\nstruct AdjListNode* newAdjListNode(int v) {\n  struct AdjListNode *newNode =\n      (struct AdjListNode *)malloc(sizeof(struct AdjListNode));\n  newNode->vertex = v;\n  newNode->next = NULL;\n  return newNode;\n}\n\n// A utility function that creates a graph of V vertices\nstruct Graph *createGraph(int V) {\n  struct Graph *graph = (struct Graph*)malloc(sizeof(struct Graph));\n  graph->n = V;\n  \n  graph->vertices = (struct AdjListNode*) malloc(V * sizeof(struct AdjListNode));\n  int i;\n  for (i = 0; i < V; ++i){\n    graph->vertices[i].next = NULL;\n    graph->vertices[i].vertex = -1;\n  }\n\n  return graph;\n}\n\n// Adds an edge to an undirected graph\nvoid addEdge(struct Graph *graph, int src, int dest) {\n  // Add an edge from src to dest.  A new node is added to the adjacency\n  // list of src.  The node is added at the begining\n  struct AdjListNode *newNode = newAdjListNode(dest);\n  newNode->next = graph->vertices[src].next;\n  graph->vertices[src].next = newNode;\n\n  // Since graph is undirected, add an edge from dest to src also. Write this part below.\n  // ...\n}\n\nint main() {\n\n  int n;\n  scanf(\"%d\", &n);\n\n  struct Graph *G = createGraph(n);\n\n  int m;\n  scanf(\"%d\", &m);\n\n  for (int i = 0; i < m; i++) {\n    int u, v;\n    scanf(\"%d\", &u);\n    scanf(\"%d\", &v);\n    addEdge(G, u, v);\n  }\n\n  int x, y;\n  \n  scanf(\"%d %d\", &x, &y);\n\n  // Write your solution here.\n  \n  return 0;\n}\n```\n\n:::\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 3. Edge List\n\n\nYou have to store the edges of a given graph as an edge list, and compute the degree of a given vertex.\n\nFor understanding how the template code works [refer to this execution](https://pythontutor.com/visualize.html#code=%23include%20%3Cstdio.h%3E%0A%0A//%20Declare%20a%20datatype%20that%20stores%20a%20single%20edge.%0A%0Astruct%20SingleEdge%7B%0A%20%20int%20ep%5B2%5D%3B%0A%20%20struct%20SingleEdge*%20nextedge%3B%0A%7D%3B%0A%0A%0A%0Aint%20main%28void%29%20%7B%0A%0A%20%20//%20To%20begin%20with,%20there%20was%20nothing.%0A%0A%20%20%0A%20%20struct%20SingleEdge*%20head%20%3D%20NULL%3B%0A%0A%20%20head%20%3D%20%28struct%20SingleEdge*%29malloc%28sizeof%28struct%20SingleEdge%29%29%3B%20%0A%20%20%20%20%0A%20%20struct%20SingleEdge*%20current%20%3D%20NULL%3B%0A%0A%20%20current%20%3D%20%28struct%20SingleEdge*%29malloc%28sizeof%28struct%20SingleEdge%29%29%3B%0A%0A%20%20%0A%20%20head-%3Eep%5B0%5D%20%3D%20-1%3B%0A%20%20head-%3Eep%5B1%5D%20%3D%20-1%3B%0A%0A%20%20//%20Read%20the%20number%20of%20edges.%0A%20%20%0A%20%20int%20edgelist%5B3%5D%5B2%5D%20%3D%20%7B%7B1,2%7D,%7B2,3%7D,%7B3,4%7D%7D%3B%0A%0A%20%20for%28int%20i%20%3D%200%3B%20i%20%3C%203%3B%20i%2B%2B%29%7B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20struct%20SingleEdge*%20newedge%3B%0A%20%20%20%20%0A%20%20%20%20newedge%20%3D%20%28struct%20SingleEdge*%29malloc%28sizeof%28struct%20SingleEdge%29%29%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20newedge-%3Eep%5B0%5D%20%3D%20edgelist%5Bi%5D%5B0%5D%3B%0A%20%20%20%20newedge-%3Eep%5B1%5D%20%3D%20edgelist%5Bi%5D%5B1%5D%3B%0A%20%20%20%20newedge-%3Enextedge%20%3D%20NULL%3B%0A%20%20%20%20%0A%20%20%20%20current-%3Enextedge%20%3D%20newedge%3B%20%20%20%20%0A%20%20%20%20current%20%3D%20newedge%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20if%28i%20%3D%3D%200%29%7B%0A%20%20%20%20%20%20head-%3Enextedge%20%3D%20current%3B%0A%20%20%20%20%7D%0A%20%20%7D%0A%20%20%0A%20%20return%200%3B%0A%7D&cumulative=false&heapPrimitives=nevernest&mode=edit&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false) on a hard-coded example.\n\n### Input\n\nThe first line contains a number `m`, which is the number of edges in the graph G.\n\nThe next `m` lines contain two space-separated integers represnting the endpoints of the edges.\n\nThe last line contains a single integer `k`.\n\n### Output\n\nThe task is to report the degree of the vertex `k`, that is, the number of edges for which `k` is one of the endpoints.\n\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n6\n1 3\n2 1\n5 3\n1 7\n1 8\n2 5\n1\n```\n  \n`Sample Output`\n\n```default\n4\n```\n\n### Template Code\n\n```C\n#include <stdio.h>\n\n// Declare a datatype that stores a single edge.\n\nstruct SingleEdge {\n  int ep[2];\n  struct SingleEdge *nextedge;\n};\n\nint main(void) {\n\n  // To begin with, there was nothing.\n  struct SingleEdge *head = NULL;\n  head = (struct SingleEdge *)malloc(sizeof(struct SingleEdge));\n\n  struct SingleEdge *current = NULL;\n  current = (struct SingleEdge *)malloc(sizeof(struct SingleEdge));\n\n  // head simply points to the first element of the list.\n  // current will move forward as things get added.\n\n  head->ep[0] = -1;\n  head->ep[1] = -1;\n  head->nextedge = current;\n\n  // Read the number of edges.\n\n  int m;\n  scanf(\"%d\", &m);\n\n  for (int i = 0; i < m; i++) {\n\n    struct SingleEdge *newedge;\n\n    newedge = (struct SingleEdge *)malloc(sizeof(struct SingleEdge));\n\n    // Populate the newedge struct\n    // with information about the current edge.\n\n    current->nextedge = newedge;\n    current = newedge;\n  }\n\n  struct SingleEdge *navigator = head->nextedge;\n  int degree = 0;\n  int vertex;\n\n  scanf(\"%d\", &vertex);\n\n  while (navigator) {\n    // CHECK IF \"vertex\" is an endpoint\n    // of the current edge being explored.\n    if (...) {\n      degree = degree + 1;\n    }\n    navigator = navigator->nextedge;\n  }\n\n  printf(\"%d\", degree);\n\n  return 0;\n}\n```\n\n:::\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 4. Sanity Check\n\nGiven a simple (no selfloops or multiedges), **connected** (any two vertices are reachable from each other), and undirected (no edge orientations) graph as input, return YES if it has a Euler path OR circuit, and NO otherwise.\n\nYou may assume the following:\n\n- An undirected graph has an Eulerian cycle if and only if every vertex has even degree, and all of its vertices with nonzero degree belong to a single connected component.\n\n- An undirected graph has an Eulerian path if and only if exactly zero or two vertices have odd degree, and all of its vertices with nonzero degree belong to a single connected component.\n\n\n### Input\n\nThe first line of input is two space-separated integers `n` and `m`, denoting the number of vertices and edges of `G`, respectively. Vertices are indexed from `0` to `n-1`.\n\nThe next `m` lines of code are two space separated integers `u` and `v` in the range `0` and `n-1`, indicating an (undirected) edge between vertices `u` and `v`.\n\n\n### Output\n\nOutput YES if it has a Euler path or circuit, and NO otherwise.\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n10 6\n1 3\n2 1\n5 3\n1 7\n1 8\n2 5\n```\n\n`Sample Output`\n\n```default\nYES\n```\n\n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 5. [Optional] Which Way is the Highway?\n\nImagine a grid country with nm axis-parallel highways (no kidding: check out this [video](https://www.youtube.com/watch?v=8Fn_30AD7Pk) about the U.S. interstate highway numbering system! - watching the video is not required for understanding this problem).\n\nOf these highways, $n$ are east-west and m are north-south. Note that the highways form an $(n - 1) \\times (m - 1)$ grid. In order to control the traffic, a policy was enforced which involved making each highway one way.\n\nThis means in each east-west highway, the traffic moves from \"left to right\" or \"right to left\". Also, traffic moves \"top to bottom\" or \"bottom to top\" in each highway that runs north-south. It is possible to enter a horizontal highway from a vertical highway, or vice versa, at their intersection.\n\nA proposed set of orientations is given to you. You have to figure out if it is possible, after making the highways one-way based on these suggested orientations, if it is possible to reach any intersection from any other (without breaking traffic rules!)\n\n### Input\n\nThe first line of input contains two integers $n$ and $m$, denoting the number of east-west highways and the number of north-south highways.\n\nThe second line contains a string of length $n$, made of characters '{' and '}', denoting direction of each horizontal highway. If the i-th character is equal to '{', the highway is directed from right to left otherwise, the highway is directed from left to right. Highways are listed in order from top to bottom.\n\nThe third line contains a string of length m, made of characters 'B' and 'T', denoting direction of each vertical highway. If the i-th character is equal to 'T', the highway is directed from south to north (towards the top), and if it is 'B' the highway is directed from north to south (towards the bottom). Highways are listed in order from left to right.\n\n### Output\n\nIf the given pattern meets the mayor's criteria, print a single line containing \"YES\", otherwise print a single line containing \"NO\".\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n3 3\n}{}\nBTB\n```\n\n`Sample Output`\n\n```default\nNO\n```\n\n`Sample Input`\n\n```default\n4 6\n{}{}\nBTBTBT\n```\n\n`Sample Output`\n\n```default\nYES\n```\n\n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 6. [Optional] Edge Orientation Puzzle\n\n\nLet's say that a vertex in a directed graph is _balanced_ if its indegree is the same as its outdegree.\n\nYou are given a simple and undirected graph $G$. An orientation of $G$ is an assigment of a direction to every edge in $G$. \n\nYou want to come up with an orientation that maximizes the number of balanced vertices. \n\nReturn the number of balanced vertices in a orientation that maximizes this number.\n\n### Input\n\nThe first line contains a positive integer $t~(1 \\leqslant t \\leqslant 200)$ — the number of testsets in the input.\n\nEach of the testsets is given in the following way. \n\nThe first line contains two integers $n$ and $m$ $(1 \\leqslant n \\leqslant 200, 0 \\leqslant m \\leqslant n·(n - 1) / 2)$ — the number of vertices and the number of edges in $G$.\n\nThe next m lines contain the description of the edges. Each line contains two integers $u$ and $v$ $(1 \\leqslant u, v \\leqslant n)$ — the endpoints of the edge. It's guaranteed that there are no self-loops and multiedges. It is possible that the graph is not connected.\n\n### Output\n\nFor each testset print the number of balanced vertices in an orientation that maximizes the number of balanced vertices.\n\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n2\n5 5\n2 1\n4 5\n2 3\n1 3\n3 5\n7 2\n3 7\n4 2\n```\n\n`Sample Output`\n\n```default\n3\n3\n```\n\n\nHere is an orientation of the first graph that has three balanced vertices:\n\n```default\n1 3\n3 5\n5 4\n3 2\n2 1\n```\n\nIn the second graph, no matter how the two edges are oriented, there will be four imbalanced and three balanced vertices.\n\n\n:::\n\n\n## List of Practice Problems\n\n1. [Weird Journey](https://codeforces.com/contest/789/problem/D) - if you already know how to check if a graph is connected, go for this! Otherwise you could come back to it after learning BFS/DFS :)\n2. [ROOKPATH](https://www.codechef.com/problems/ROOKPATH) - can you figure out how to model this problem as finding an Euler Tour?\n3. [Mashtali: a Space Oddysey](https://codeforces.com/contest/1610/problem/F) - at least one method of solving this question involves constructing an Euler tour (but it is less direct than the previous problem), revisit it once you have figured out how to.\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["fontawesome"],"css":["../../../styles.css","/css/teaching.css"],"toc":false,"include-in-header":[{"text":"<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Berkshire+Swash&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap\" rel=\"stylesheet\">\n<link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n<script>\nwindow.addEventListener('load', function() {\n  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')); \n  tooltipTriggerList.forEach(function(element) {\n    new bootstrap.Tooltip(element, {\n      trigger: 'hover',\n      animation: true,\n      delay: { show: 50, hide: 50 }\n    });\n  });\n});\n</script>\n"}],"output-file":"lab-w04.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo","js":"../../../scripts.js","page-layout":"full","sidebar":false,"title":"ES242. Data Structures and Algorithms I. Week 04 Lab","code-copy":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
{"title":"ES242. Data Structures and Algorithms I. Week 03 Lab","markdown":{"yaml":{"css":"/css/teaching.css","toc":false,"sidebar":false,"title":"ES242. Data Structures and Algorithms I. Week 03 Lab","code-copy":true},"headingText":"ES242. Data Structures and Algorithms I.","containsRefs":false,"markdown":"\n\n:::{.column-body-outset}\n\n\n##### Lab 03\n\n[Back to course page](../index.qmd)\n\n:::{.callout-warning appearance=\"minimal\"}\nTheme: Stacks\n:::\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 1. Linked Lists\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n{\n  //node structure\n  struct node\n  {\n      int data;\n      struct node *next;\n  };\n\n  //declaring nodes\n  struct node *head,*middle,*last;\n\n  //allocating memory for each node\n  head   = malloc(sizeof(struct node));\n  middle = malloc(sizeof(struct node));\n  last   = malloc(sizeof(struct node));\n\n  //assigning values to each node\n  head->data   = 10;\n  middle->data = 20;\n  last->data   = 30;\n\n  //connecting each nodes. head->middle->last\n  head->next   = middle;\n  middle->next = last;\n  last->next   = NULL;\n\n  //temp is a reference for head pointer.\n  struct node *temp = head;\n\n  //till the node becomes null, printing each nodes data\n  while(temp != NULL)\n  {\n      printf(\"%d->\",temp->data);\n      temp = temp->next;\n  }\n  printf(\"NULL\");\n\n  return 0;\n}\n```\n\nExtend the code above to perform the following tasks:\n\n1. Read a sequence of `n` numbers from the input, $p_1, \\ldots, p_n$.\n2. Insert each of these number at a location where the linked list is still sorted when read from beginning to end.\n3. For any given input $i$, output the number in the linked list that comes before the number $i$.\n\n### Input\n\nThe first line contains a positive integer `n`.\nThe second line contains `n` space-separated integers.\nThe third line contains a positive integer `m`.\n\n### Output\n\nOutput the number that comes before `m` in the linked list. It is guaranteed that `m` is one of the numbers from the second line. If the number happens to be the first element of the list, return `-1`.\n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 2. Parentheses\n\nYou are given a string consisting of parentheses `(` and `)`. A string of this type is said to be _correct_:\n\n(a) if it is the empty string\n\n(b) if A and B are correct, AB is correct.\n\n(c) if A is correct, (A) is correct.\n\n\nWrite a program that takes a sequence of strings of this of type and check their correctness. \n\nYour program can assume that the maximum string length is 128. \n\n### Input\n\nThe first line of the input is a positive integer `n`, the number of tests.\nThe next `n` lines consist of one test case each.\nEach test case is a string made of the parentheses `()`.\n\n### Output\n\nThe output should consist of `n` lines, one for each test.\nThe `i`-th line of the ouptut should be `Yes` if the the string in the `i`-th test case is correct, and `No` otherwise.\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n5\n(\n(((\n()()\n)\n)))\n```\n\n`Sample Output`\n\n```default\nNo\nNo\nYes\nNo\nNo\n```\n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 3. Challenge the Parentheses Solution\n\nConsider the following algorithm for the previous problem:\n\n```default\nIf the first character is not ( return FALSE\nIf the last character is not ) return FALSE\nInitialize i = 0\nFor j in s:\n    if j == \"(\":\n        i++\n    else:\n        i--\nif i != 0 return FALSE\nelse return TRUE\n```\n\nProvide an input for which the algorithm above does _not_ work. Your input should be a single line consisting of a string that has `(` and `)` characters only. \n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 4. Print Alternate Cards\n\nAdd a set of cards to a stack and print all the cards in odd-numbered positions of the stack.\n\n### I/O Format\n\nThe first line contains a number `n`, the number of cards in the stack. The next `n` lines contain two numbers. The first number `b` indicates if the card is to be added on the top (`b=0`) or at the bottom (`b=1`). The second number indicates the card's value, an integer between 1 and 52.\n\nThe output should the list of alternating cards from bottom to top (i.e, starting at the card pointed to by the first pointer). If there are an even number of cards, note that the last card on the stack does not get printed.\n\nAdding a card on the top can be done by using `pushBack`, while adding it at the bottom `pushFront`.\n\n### Sample I/O\n\n`Sample Input`\n```default\n5\n0 1\n0 2\n1 3\n1 5\n0 4\n```\n`Sample Output`\n\n```default\n5\n1\n4\n```\n\n:::\n\n### The Cardstack Data Structure\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct s_card {\n  int cardvalue;\n  struct s_card *next;\n  struct s_card *prev;\n} t_card;\n\ntypedef struct s_cardstack {\n  struct s_card *first;\n  struct s_card *last;\n} t_cardstack;\n\nt_cardstack *cardstackInit() {\n  t_cardstack *cardstack;\n  cardstack = malloc(sizeof(t_cardstack));\n  cardstack->first = NULL;\n  cardstack->last = NULL;\n  return cardstack;\n}\n\nint isEmpty(t_cardstack *cardstack) { return !cardstack->first; }\n\nvoid pushFront(t_cardstack *cardstack, int cardvalue) {\n  t_card *node = malloc(sizeof(t_card));\n  node->cardvalue = cardvalue;\n  node->prev = NULL;\n  node->next = cardstack->first;\n  if (isEmpty(cardstack))\n    cardstack->last = node;\n  else\n    cardstack->first->prev = node;\n  cardstack->first = node;\n}\n\nvoid pushBack(t_cardstack *cardstack, int cardvalue) {\n  t_card *node = malloc(sizeof(t_card));\n  node->cardvalue = cardvalue;\n  node->prev = cardstack->last;\n  node->next = NULL;\n  if (isEmpty(cardstack))\n    cardstack->first = node;\n  else\n    cardstack->last->next = node;\n  cardstack->last = node;\n}\n\nint popFront(t_cardstack *cardstack) {\n  t_card *node;\n  int cardvalue;\n  if (isEmpty(cardstack))\n    return -1;\n  node = cardstack->first;\n  cardstack->first = node->next;\n  if (!cardstack->first)\n    cardstack->last = NULL;\n  else\n    cardstack->first->prev = NULL;\n  cardvalue = node->cardvalue;\n  free(node);\n  return cardvalue;\n}\n\nint popBack(t_cardstack *cardstack) {\n  t_card *node;\n  int cardvalue;\n  if (isEmpty(cardstack))\n    return -1;\n  node = cardstack->last;\n  cardstack->last = node->prev;\n  if (!cardstack->last)\n    cardstack->first = NULL;\n  else\n    cardstack->last->next = NULL;\n  cardvalue = node->cardvalue;\n  free(node);\n  return cardvalue;\n}\n\nint peekFront(t_cardstack *cardstack) {\n  if (isEmpty(cardstack))\n    return -1;\n  return cardstack->first->cardvalue;\n}\n\nint peekBack(t_cardstack *cardstack) {\n  if (isEmpty(cardstack))\n    return -1;\n  return cardstack->last->cardvalue;\n}\n\nvoid *fronttoback(t_cardstack *cardstack) {\n  if (isEmpty(cardstack))\n    return NULL;\n  t_card *currpointer = cardstack->last;\n  while (currpointer) {\n    printf(\"%d\\n\", currpointer->cardvalue);\n    currpointer = currpointer->prev;\n  }\n}\n\nint main() { \n  t_cardstack *ms;\n  // Remember to initialize!\n  return 0; \n}\n```\n:::\n\n## List of Practice Problems\n\n1. [Compilers](https://www.codechef.com/problems/COMPILER) - a slight adaptation of the second problem in this lab.\n2. [Alternating Current](https://codeforces.com/contest/343/problem/B) - try to come up with a characterization of when the wires can be untangled in terms of the symbols.\n3. [Largest Rectangle in a Histogram](https://www.spoj.com/problems/HISTOGRA/) - a fun problem. See if you can make use of the cardstack!\n\n:::","srcMarkdownNoYaml":"\n\n:::{.column-body-outset}\n\n## ES242. Data Structures and Algorithms I.\n\n##### Lab 03\n\n[Back to course page](../index.qmd)\n\n:::{.callout-warning appearance=\"minimal\"}\nTheme: Stacks\n:::\n\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n# Problem 1. Linked Lists\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n{\n  //node structure\n  struct node\n  {\n      int data;\n      struct node *next;\n  };\n\n  //declaring nodes\n  struct node *head,*middle,*last;\n\n  //allocating memory for each node\n  head   = malloc(sizeof(struct node));\n  middle = malloc(sizeof(struct node));\n  last   = malloc(sizeof(struct node));\n\n  //assigning values to each node\n  head->data   = 10;\n  middle->data = 20;\n  last->data   = 30;\n\n  //connecting each nodes. head->middle->last\n  head->next   = middle;\n  middle->next = last;\n  last->next   = NULL;\n\n  //temp is a reference for head pointer.\n  struct node *temp = head;\n\n  //till the node becomes null, printing each nodes data\n  while(temp != NULL)\n  {\n      printf(\"%d->\",temp->data);\n      temp = temp->next;\n  }\n  printf(\"NULL\");\n\n  return 0;\n}\n```\n\nExtend the code above to perform the following tasks:\n\n1. Read a sequence of `n` numbers from the input, $p_1, \\ldots, p_n$.\n2. Insert each of these number at a location where the linked list is still sorted when read from beginning to end.\n3. For any given input $i$, output the number in the linked list that comes before the number $i$.\n\n### Input\n\nThe first line contains a positive integer `n`.\nThe second line contains `n` space-separated integers.\nThe third line contains a positive integer `m`.\n\n### Output\n\nOutput the number that comes before `m` in the linked list. It is guaranteed that `m` is one of the numbers from the second line. If the number happens to be the first element of the list, return `-1`.\n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 2. Parentheses\n\nYou are given a string consisting of parentheses `(` and `)`. A string of this type is said to be _correct_:\n\n(a) if it is the empty string\n\n(b) if A and B are correct, AB is correct.\n\n(c) if A is correct, (A) is correct.\n\n\nWrite a program that takes a sequence of strings of this of type and check their correctness. \n\nYour program can assume that the maximum string length is 128. \n\n### Input\n\nThe first line of the input is a positive integer `n`, the number of tests.\nThe next `n` lines consist of one test case each.\nEach test case is a string made of the parentheses `()`.\n\n### Output\n\nThe output should consist of `n` lines, one for each test.\nThe `i`-th line of the ouptut should be `Yes` if the the string in the `i`-th test case is correct, and `No` otherwise.\n\n### Sample I/O\n\n`Sample Input`\n\n```default\n5\n(\n(((\n()()\n)\n)))\n```\n\n`Sample Output`\n\n```default\nNo\nNo\nYes\nNo\nNo\n```\n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 3. Challenge the Parentheses Solution\n\nConsider the following algorithm for the previous problem:\n\n```default\nIf the first character is not ( return FALSE\nIf the last character is not ) return FALSE\nInitialize i = 0\nFor j in s:\n    if j == \"(\":\n        i++\n    else:\n        i--\nif i != 0 return FALSE\nelse return TRUE\n```\n\nProvide an input for which the algorithm above does _not_ work. Your input should be a single line consisting of a string that has `(` and `)` characters only. \n:::\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n# Problem 4. Print Alternate Cards\n\nAdd a set of cards to a stack and print all the cards in odd-numbered positions of the stack.\n\n### I/O Format\n\nThe first line contains a number `n`, the number of cards in the stack. The next `n` lines contain two numbers. The first number `b` indicates if the card is to be added on the top (`b=0`) or at the bottom (`b=1`). The second number indicates the card's value, an integer between 1 and 52.\n\nThe output should the list of alternating cards from bottom to top (i.e, starting at the card pointed to by the first pointer). If there are an even number of cards, note that the last card on the stack does not get printed.\n\nAdding a card on the top can be done by using `pushBack`, while adding it at the bottom `pushFront`.\n\n### Sample I/O\n\n`Sample Input`\n```default\n5\n0 1\n0 2\n1 3\n1 5\n0 4\n```\n`Sample Output`\n\n```default\n5\n1\n4\n```\n\n:::\n\n### The Cardstack Data Structure\n\n:::{.callout-note collapse=\"true\" icon=\"false\"}\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct s_card {\n  int cardvalue;\n  struct s_card *next;\n  struct s_card *prev;\n} t_card;\n\ntypedef struct s_cardstack {\n  struct s_card *first;\n  struct s_card *last;\n} t_cardstack;\n\nt_cardstack *cardstackInit() {\n  t_cardstack *cardstack;\n  cardstack = malloc(sizeof(t_cardstack));\n  cardstack->first = NULL;\n  cardstack->last = NULL;\n  return cardstack;\n}\n\nint isEmpty(t_cardstack *cardstack) { return !cardstack->first; }\n\nvoid pushFront(t_cardstack *cardstack, int cardvalue) {\n  t_card *node = malloc(sizeof(t_card));\n  node->cardvalue = cardvalue;\n  node->prev = NULL;\n  node->next = cardstack->first;\n  if (isEmpty(cardstack))\n    cardstack->last = node;\n  else\n    cardstack->first->prev = node;\n  cardstack->first = node;\n}\n\nvoid pushBack(t_cardstack *cardstack, int cardvalue) {\n  t_card *node = malloc(sizeof(t_card));\n  node->cardvalue = cardvalue;\n  node->prev = cardstack->last;\n  node->next = NULL;\n  if (isEmpty(cardstack))\n    cardstack->first = node;\n  else\n    cardstack->last->next = node;\n  cardstack->last = node;\n}\n\nint popFront(t_cardstack *cardstack) {\n  t_card *node;\n  int cardvalue;\n  if (isEmpty(cardstack))\n    return -1;\n  node = cardstack->first;\n  cardstack->first = node->next;\n  if (!cardstack->first)\n    cardstack->last = NULL;\n  else\n    cardstack->first->prev = NULL;\n  cardvalue = node->cardvalue;\n  free(node);\n  return cardvalue;\n}\n\nint popBack(t_cardstack *cardstack) {\n  t_card *node;\n  int cardvalue;\n  if (isEmpty(cardstack))\n    return -1;\n  node = cardstack->last;\n  cardstack->last = node->prev;\n  if (!cardstack->last)\n    cardstack->first = NULL;\n  else\n    cardstack->last->next = NULL;\n  cardvalue = node->cardvalue;\n  free(node);\n  return cardvalue;\n}\n\nint peekFront(t_cardstack *cardstack) {\n  if (isEmpty(cardstack))\n    return -1;\n  return cardstack->first->cardvalue;\n}\n\nint peekBack(t_cardstack *cardstack) {\n  if (isEmpty(cardstack))\n    return -1;\n  return cardstack->last->cardvalue;\n}\n\nvoid *fronttoback(t_cardstack *cardstack) {\n  if (isEmpty(cardstack))\n    return NULL;\n  t_card *currpointer = cardstack->last;\n  while (currpointer) {\n    printf(\"%d\\n\", currpointer->cardvalue);\n    currpointer = currpointer->prev;\n  }\n}\n\nint main() { \n  t_cardstack *ms;\n  // Remember to initialize!\n  return 0; \n}\n```\n:::\n\n## List of Practice Problems\n\n1. [Compilers](https://www.codechef.com/problems/COMPILER) - a slight adaptation of the second problem in this lab.\n2. [Alternating Current](https://codeforces.com/contest/343/problem/B) - try to come up with a characterization of when the wires can be untangled in terms of the symbols.\n3. [Largest Rectangle in a Histogram](https://www.spoj.com/problems/HISTOGRA/) - a fun problem. See if you can make use of the cardstack!\n\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["fontawesome"],"css":["../../../styles.css","/css/teaching.css"],"toc":false,"include-in-header":[{"text":"<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Berkshire+Swash&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap\" rel=\"stylesheet\">\n<link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n<script>\nwindow.addEventListener('load', function() {\n  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')); \n  tooltipTriggerList.forEach(function(element) {\n    new bootstrap.Tooltip(element, {\n      trigger: 'hover',\n      animation: true,\n      delay: { show: 50, hide: 50 }\n    });\n  });\n});\n</script>\n"}],"output-file":"lab-w03.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo","js":"../../../scripts.js","page-layout":"full","sidebar":false,"title":"ES242. Data Structures and Algorithms I. Week 03 Lab","code-copy":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
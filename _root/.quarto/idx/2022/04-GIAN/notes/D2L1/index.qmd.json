{"title":"191014K02 | Day 2 Lecture 1","markdown":{"yaml":{"title":"191014K02 | Day 2 Lecture 1","sidebar":false,"toc":false,"css":["/css/teaching.css","/css/feedback-override.css"]},"headingText":"191014K02: Day 2 Lecture 1","containsRefs":false,"markdown":"\n\n:::{.column-body-outset}\n\n\n_[Back to the Course Page](../../)_\n\n\n### Vertex Cover\n\n:::{.callout-tip}\n\n# Vertex Cover [Optimization]\n\nInput: A graph $G = (V,E)$.\n\nTask: Find $S \\subseteq V(G)$ such that for all edges $(u,v) \\in E(G)$, $\\{u,v\\} \\cap S \\neq \\varnothing$ and <span style=\"color:indianred;\">minimize $|S|$</span>.\n:::\n\n:::{.callout-tip}\n\n# Vertex Cover [Decision Version Edition]\n\nInput: A graph $G = (V,E)$ and $k \\in \\mathbb{Z}^+$.\n\nTask: Find $S \\subseteq V(G)$ such that for all edges $(u,v) \\in E(G)$, $\\{u,v\\} \\cap S \\neq \\varnothing$ and <span style=\"color:indianred;\">$|S| \\leqslant k$</span>.\n:::\n\nThe naive algorithm by brute force --- examining all possible subsets --- is $O(n^k \\cdot m)$ in damages. Can we do better?\n\nThe answer turns out to be yes: we can improve from $O(n^k \\cdot m)$ to deterministic $2^k \\cdot n^{O(1)}$ time, which is fixed-parameter tractable in $k$.\n\nHaving said that, we will begin with a very elegant randomized algorithm for Vertex Cover, which essentially picks an edge at random and then, one of its endpoints at random, for as long as it can.\n\n:::{.callout-note}\n\n# Cute randomized algorithm `ALG`\n\n$S=\\varnothing$\n\nwhile $G-S$ has at least one edge:\n\n- pick $u,v \\in E(G-S)$ u.a.r. \n- pick $s \\in\\{u,v\\}$ u.a.r\n- Set $S \\leftarrow S \\cup\\{s\\}$\n\nOutput $S$\n:::\n\nHere are few claims about cute algorithm:\n\n1. `ALG` always runs in polynomial^[(even linear)] time.\n2. $S$ is always a vertex cover.\n3. $\\operatorname{Pr}$[<span style=\"color:indianred;\">$S$ is an optimal vertex cover</span>] $\\geqslant 1/2^k$. {{< bi heart-half color=\"indianred\" >}}\n\nThe first two claims follow quite directly from the operations of the algorithm and the definition of a vertex cover. \n\nWhat about the third? Well: let `OPT` be some fixed optimal vertex cover. Suppose $|$`OPT`$| \\leqslant k$. Initially, note that $S \\subseteq$ `OPT`. In each round, $\\operatorname{Pr}$[<span style=\"color:indianred;\">$s \\in S$</span>] $\\geqslant 1/2$, since $S \\cap \\{u,v\\} \\neq \\varnothing$ by definition. If $s \\in$ `OPT` in _every_ round of the algorithm, then $S =$ `OPT`, which is awesome: and said awesomeness manifests with probability $1/2^k$. \n\nBonus: repeat the algorithm and retain the smallest solution to get an overall constant success probability:\n\n$$1-\\left(1-\\frac{1}{2^k}\\right)^{2^k} \\geqslant 1-1 / e.$$\n\n**Approximation.** Do we expect `ALG` to be a reasonable approximation? It turns out: yes! {{< bi emoji-sunglasses >}}\n\nIn particular: we will show that the size of the vertex cover output by `ALG` is at most twice $|$`OPT`$|$ in expectation.\n\nFor a graph $G$, define $X_G$ to be the radom variable returning the size of the set $S$ output by the algorithm.\n\nFor integers $k,n$ define:\n$$\nX_{n,k}=\\max_G E[X_G],\n$$\n\nwhere the $\\max$ is taken over all graphs with $\\leqslant n$ vertices^[We could have also considered $X_k = \\max_G E[X_G]$, where the max is over all graphs whose vertex cover is at most $k$: but there are infinitely many graphs that have vertex covers of size at most $k$, and it is not _immediate_ that the max is well-defined, so we restrict ourselves to graphs on $n$ vertices that have vertex covers of size at most $k$.] and vertex cover of size $\\leqslant k$. \n\nNow let's analyze the number $X_{n,k}$. Let $G^\\star$ be the \"worst-case graph\" that bears witness to the $\\max$ in the definition of $X_{n,k}$. Run the first step of `ALG` on $G^\\star$. Suppose we choose to pick ${\\color{indianred}s}$ in this step.\n$$\n\\begin{aligned}\nX_{n,k}=E[X_{G^\\star}] & = {\\color{indianred}1}+\\left(\\frac{1}{2}+\\varepsilon \\right) E\\left[{\\color{darkseagreen}X_{G^\\star-s} \\mid s \\in \\text{OPT}}\\right]+\\left(\\frac{1}{2} - \\varepsilon\\right) E\\left[{\\color{palevioletred}X_{G^\\star-s} \\mid s \\notin \\text {OPT}}\\right] \\\\\n& = 1 + \\left(\\frac{1}{2} + \\varepsilon \\right){\\color{darkseagreen}X_{n, k-1}}+ \\left(\\frac{1}{2} - \\varepsilon \\right){\\color{palevioletred}X_{n-1, k}}\\\\\n& \\leqslant 1 + \\left(\\frac{1}{2} + \\varepsilon \\right){\\color{darkseagreen}X_{n, k-1}}+ \\left(\\frac{1}{2} - \\varepsilon \\right){\\color{dodgerblue}X_{n, k}}\\\\\n& = 1 + \\frac{1}{2} X_{n, k-1} + \\varepsilon \\cdot X_{n, k-1} + \\frac{1}{2} X_{n, k} - \\varepsilon X_{n, k}\\\\\n& \\leqslant 1 + \\frac{1}{2} X_{n, k-1} + \\varepsilon \\cdot {\\color{dodgerblue}X_{n, k}} + \\frac{1}{2} X_{n, k} - \\varepsilon X_{n, k}\\\\\n& = 1 + \\frac{1}{2} X_{n, k-1} + {\\color{indianred}\\varepsilon \\cdot X_{n, k}} + \\frac{1}{2} X_{n, k} - {\\color{indianred}\\varepsilon X_{n, k}}\\\\\n& = 1 + \\frac{1}{2} X_{n, k-1} + \\frac{1}{2} X_{n, k} \n\\end{aligned}\n$$\n\nNote that:\n\n- <span style=\"color:dodgerblue;\"> $X_{n,k} \\geqslant X_{n-1,k}$ and  $X_{n,k} \\geqslant X_{n,k-1}$.</span>\n- $\\operatorname{Pr}[s \\in \\text{OPT}] \\geqslant \\frac{1}{2}$, in particular we let $\\operatorname{Pr}[s \\in \\text{OPT}] = \\frac{1}{2} + \\varepsilon$.\n- $\\operatorname{Pr}[s \\notin \\text{OPT}] = 1 - \\operatorname{Pr}[s \\in \\text{OPT}] = \\frac{1}{2} - \\varepsilon$.\n- <span style=\"color:darkseagreen;\"> ${\\color{darkseagreen}G^\\star-s}$ is a graph on at most ${\\color{darkseagreen}n}$ vertices with a vertex cover of size ${\\color{darkseagreen}\\leqslant k-1}$\n- <span style=\"color:palevioletred;\"> ${\\color{palevioletred}G^\\star-s}$ is a graph on at most ${\\color{palevioletred}n}$ vertices with a vertex cover of size ${\\color{palevioletred}\\leqslant k}$\n\nRearranging terms, we get:\n\n$$\\frac{1}{2} X_{n,k} \\leqslant 1 + \\frac{1}{2} X_{n,k-1} \\equiv X_{n,k} \\leqslant 2 + X_{n,k-1}$$\n\nExpanding the recurrence, we have: $X_{n,k} \\leqslant 2k$, as claimed earlier.\n\n\n### Feedback Vertex Set\n\nNow we turn to a problem similar to vertex cover, except that we are \"killing cycles\" instead of \"killing edges\".\n\n\n:::{.callout-tip}\n\n# Feedback Vertex Set\n\nInput: A (multi-)^[We allow for more than one edge between a fixed pair of vertices and self-loops.]graph $G = (V,E)$.\n\nTask: Find $S \\subseteq V(G)$ such that $G \\setminus S$ is a forest^[A graph without cycles that is not necessarily connected.], and <span style=\"color:indianred;\">minimize $|S|$</span>.\n\n:::\n\nIf we try to mimic the cute algorithm from before, we might easily be in trouble: note that the driving observation --- that an edge has at least one of its endpoints in the solution with a reasonable enough probability --- can fail spectacularly for FVS:\n\n![An example showing that for \"most edges\", _both_ endpoints do not belong to an optimal solution.](../images/fvs-badex.png){width=70%}\n\nOne thing about this example is the large number of pendant vertices sticking out prominently, and these clearly contribute to the badness of the situation. Happily, it turns out that we can get rid of these:\n\n\n:::{.callout-important icon=\"false\"}\n\n# Lemma 1. Delete pendant and isolated vertices\n\nLet $G$ be a multi-graph and $v$ be a vertex of degree $\\leqslant 1$. Then:\n\n- MinFVS of $G-\\{v\\}$ $\\leqslant$ MinFVS of $G$\n\n- $\\forall S \\subseteq V(G)-\\{v\\}$: <span style=\"color:#CC0000;\"> $S$ is an FVS for $G$ </span> $\\leftrightarrow$ <span style=\"color:#CC0000;\">$S$ is an FVS for $G \\setminus \\{v\\}$  </span>\n\n:::\n\nConsider graphs with no pendant vertices and fix an optimal FVS $S$. Is it true that a reasonable fraction of edges are guaranteed to be incident to $S$? Well... not yet:\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Spoiler\n\n![An(other) example showing that for \"most edges\", _both_ endpoints do not belong to an optimal solution, even though the graph has no pendant vertices.](../images/fvs-badex-deg2.png){width=70%}\n\n:::\n\nHowever, continuing our approach of conquering-by-observing-patterns-in-counterexamples, note that the example above has an _abundance_ of vertices that have degree two. Can we get rid of them? Well, isolated and pendant vertices were relatively easy because they don't even belong to cycles, but _that_ is not quite true for vertices of degree two. Can we still hope to shake them off?\n\nOne thing about a degree two vertex $u$ is that if there is a cycle that contains $u$ it _must_ contain both its neighbors^[Except when the cycle _only_ contains $u$, i.e, $u$ has a self-loop.]. So you might suggest that we can ditch $u$ and just work with its neighbors instead. This intuition, it turns out, can indeed be formalized:\n\n\n:::{.callout-important icon=\"false\"}\n\n# Lemma 2. Short-Circuiting Degree Two Vertices\n\nLet:\n\n- $G$ be a multi-graph,\n- $u$ be a vertex of degree 2 that is not a self-loop,\n- $a$ and $b$ be the neighbors of $u$ ($a=b$ is possible).\n\nLet $H$ be the graph obtained by adding an edge $(a,b)$ to $G-\\{u\\}$.\n\nThen:\n\n- every FVS $S$ of $G$ such that $u \\notin S$ is an FVS of $H$, and\n- every FVS $S$ of $H$ is an FVS of $G$.\n\n:::\n\n![Illustrating Lemma 2 scenarios.](../images/fvs-reduction-2deg.png)\n\nLet us also get rid of self-loops (because we can):\n\n:::{.callout-important icon=\"false\"}\n\n# Lemma 3. Removing self-loops\n\nIf $G$ has a vertex $v$ with a self loop then\n\n- Every FVS $S$ of $G$ contains $v$\n- For every $S$ containing $v$: <span style=\"color:#CC0000;\">$S$ is an FVS of $G$</span> $\\leftrightarrow$ <span style=\"color:#CC0000;\">$S-v$ is an FVS of $G-\\{v\\}$</span>\n\n:::\n\nNow let's apply Lemmas 1---3 exhaustively, which is to say we keep applying them until none of them are applicable (as opposed to applying them until we feel exhausted {{< bi emoji-laughing >}} ). Once we are truly stuck, we have a graph $H$ that is: (a) a graph whose _minimum_ degree is three; and (b) equivalent to the original $G$ in the sense that any minimum FVS for $H$ can be extended to a minimum FVS of $G$ by some time travel: just play back the applications of Lemmas 1---3 in reverse order.\n\nRecall that all this work was to serve our hope for having a cute algorithm for FVS as well. Let's check in on how we are doing on that front: consider graphs whose minimum degree is three and fix an optimal FVS $S$. Is it true that a reasonable fraction of edges are guaranteed to be incident to $S$? Or can we come up with examples to demonstrate otherwise?\n\nThis is a good place to pause and ponder: play around with examples to see if you can come up with bad cases as before. If you find yourself struggling, it would be for a good reason: we actually now _do_ have the property we were after! Here's the main claim that we want to make.\n\n:::{.callout-important icon=\"false\"}\n\n# Key Lemma\n\nLet:\n\n- $G$ be a multigraph with no self loops and minimum degree $\\geqslant 3$,\n- $S$ be an FVS of $G$,\n- $(u,v)$ be a random edge in $E(G)$. \n\nThen:\n\n$\\operatorname{Pr}[{\\color{indianred}\\{u, v\\} \\cap S \\neq \\varnothing}] \\geqslant 1/2$\n\n:::\n\nWe argue this as follows: call an edge <span style=\"color:darkseagreen;\">good</span> if it has at least one of its endpoints in $S$, and <span style=\"color:indianred;\">bad</span> otherwise. \n\nWe will demonstrate that the number of good edges is at least the number of bad edges: this implies the desired claim.\n\n- **The <span style=\"color:indianred;\">bad</span> edges.** Let $X := G \\setminus S$. The bad edges are precisely $E(G[X])$.\n\n- **The <span style=\"color:darkseagreen;\">good</span> edges.** Every edge that has one of its endpoints in $X$ and the other in $S$ is a good edge. Recall that $G$ has minimum degree three, because of which:\n\n    - for every leaf in $G[X]$, we have at least _two_ good edges, and\n    - for vertex that is degree two in $G[X]$, we have at least one good edge.\n\nSo at this point, it is enough to show that twice the number of leaves and degree two vertices is at least $|E(G[X])| = |X|-1$. But this is quite intuitive if we simple stare at the following mildly stronger claim:\n\n$$2 \\cdot (\\text{\\# leaves}) + \\text{\\# deg-} 2 \\text{vertices} \\geqslant |X|$$\n\nwhich is equivalent to:\n\n$$2 \\cdot ({\\color{darkseagreen}\\text{\\# leaves}}) + {\\color{palevioletred}\\text{\\# deg-}2 \\text{vertices}} \\geqslant ({\\color{darkseagreen}\\text{\\# leaves}}) + {\\color{palevioletred}\\text{\\# deg-}2 \\text{ vertices}} + \\text{\\# deg-}(\\geqslant 3) \\text{ vertices}.$$\n\nAfter cancelations, we have:\n\n$$(\\text{\\# leaves}) \\geqslant \\text{\\# deg-}(\\geqslant 3) \\text{ vertices}.$$\n\nNote that this is true! Intuitively, the inequality is suggesting every branching vertex in a tree pays for at least one leaf --- this can be formalized by induction on $n$. \n\n\n:::{.callout-caution collapse=\"true\"}\n# Induction proof sketch\nDenote the tree by $G$ and remove a leaf $u$ to obtain $H$. Apply the induction hypothesis on $H$. \n\n- If the neighbor of $u$ in $G$ is a degree two vertex, then the number of leaves and high degree vertices are the same in $G$ and $H$, so the claim follows directly. \n- If the degree of the neighbor in $u$ is three in $G$, then both quantities in the inequality for $H$ increase by one when we transition from $H$ to $G$. \n- In the only remaining case, the quantity on the left increases by one when we come to $G$, which bodes well for the inequality. {{< bi hand-thumbs-up >}}\n:::\n\nAll this was leading up to cute randomized algorithm v2.0 --- i.e, adapted for FVS as follows:\n\n:::{.callout-note}\n\n# Cute randomized algorithm redux\n\n`ALG`$(G)$\n\n`Preprocess:`\n\n- if $G$ is acyclic return $\\varnothing$\n- if $\\exists$ a self loop $v$ RETURN $($`ALG`$(G \\setminus \\{v\\})) \\cup \\{v\\}$.\n- if $\\exists$ a degree one vertex $v$ RETURN `ALG`$(G-\\{v\\})$.\n- if $\\exists$ a degree two vertex $v$ RETURN `ALG`$(G/\\{v\\})$ (c.f. Lemma 2).\n---\n\n`Mindeg-3 instance:`\n\n- pick an edge $(u,v) \\in E(G)$ u.a.r.\n- pick $s \\in \\{u,v\\}$ u.a.r.\n- RETURN $($`ALG`$(G \\setminus \\{s\\})) \\cup \\{s\\}$\n:::\n\n\n:::{.callout-important icon=\"false\"}\n\n# Claim 1\n\n`ALG` always returns a FVS of $G$.\n\n:::\n\nThis follows from Lemmas 1---3 and induction on $n$.\n\n\n:::{.callout-important icon=\"false\"}\n\n# Claim 2\n\nIf $G$ has a FVS of size $k$, then $\\operatorname{Pr}$[`ALG` returns an optimal FVS] $\\geqslant 1/4^k$.\n:::\n\nThis follows from Lemmas 1---3, the key lemma, and induction on $n$.\n\n\n### Exact Algorithms\n\n`Coming Soon.`\n\n<!-- The running time is then given by:\n\n$\\frac{{n \\choose t}}{{k \\choose t}} \\cdot c^{k-t}$\n\n$\\min_{t \\leqslant k} \\frac{{n \\choose t}}{{k \\choose t}} \\cdot c^{k-t}$\n\n$\\leqslant \\max_{k \\leqslant n} \\min _{t \\leqslant k} \\frac{{n \\choose t}}{k \\choose t} \\cdot c^{k-t}$\n\n$\\leqslant \\left(2-\\frac{1}{c}\\right)^n \\cdot \\operatorname{poly}(n)$\n\n\nThis leads to an $O(1.5^n)$ algorithm for Vertex Cover and an $O(1.75^n)$ algorithm for Feedback Vertex Set. -->\n\n\n:::","srcMarkdownNoYaml":"\n\n:::{.column-body-outset}\n\n## 191014K02: Day 2 Lecture 1\n\n_[Back to the Course Page](../../)_\n\n\n### Vertex Cover\n\n:::{.callout-tip}\n\n# Vertex Cover [Optimization]\n\nInput: A graph $G = (V,E)$.\n\nTask: Find $S \\subseteq V(G)$ such that for all edges $(u,v) \\in E(G)$, $\\{u,v\\} \\cap S \\neq \\varnothing$ and <span style=\"color:indianred;\">minimize $|S|$</span>.\n:::\n\n:::{.callout-tip}\n\n# Vertex Cover [Decision Version Edition]\n\nInput: A graph $G = (V,E)$ and $k \\in \\mathbb{Z}^+$.\n\nTask: Find $S \\subseteq V(G)$ such that for all edges $(u,v) \\in E(G)$, $\\{u,v\\} \\cap S \\neq \\varnothing$ and <span style=\"color:indianred;\">$|S| \\leqslant k$</span>.\n:::\n\nThe naive algorithm by brute force --- examining all possible subsets --- is $O(n^k \\cdot m)$ in damages. Can we do better?\n\nThe answer turns out to be yes: we can improve from $O(n^k \\cdot m)$ to deterministic $2^k \\cdot n^{O(1)}$ time, which is fixed-parameter tractable in $k$.\n\nHaving said that, we will begin with a very elegant randomized algorithm for Vertex Cover, which essentially picks an edge at random and then, one of its endpoints at random, for as long as it can.\n\n:::{.callout-note}\n\n# Cute randomized algorithm `ALG`\n\n$S=\\varnothing$\n\nwhile $G-S$ has at least one edge:\n\n- pick $u,v \\in E(G-S)$ u.a.r. \n- pick $s \\in\\{u,v\\}$ u.a.r\n- Set $S \\leftarrow S \\cup\\{s\\}$\n\nOutput $S$\n:::\n\nHere are few claims about cute algorithm:\n\n1. `ALG` always runs in polynomial^[(even linear)] time.\n2. $S$ is always a vertex cover.\n3. $\\operatorname{Pr}$[<span style=\"color:indianred;\">$S$ is an optimal vertex cover</span>] $\\geqslant 1/2^k$. {{< bi heart-half color=\"indianred\" >}}\n\nThe first two claims follow quite directly from the operations of the algorithm and the definition of a vertex cover. \n\nWhat about the third? Well: let `OPT` be some fixed optimal vertex cover. Suppose $|$`OPT`$| \\leqslant k$. Initially, note that $S \\subseteq$ `OPT`. In each round, $\\operatorname{Pr}$[<span style=\"color:indianred;\">$s \\in S$</span>] $\\geqslant 1/2$, since $S \\cap \\{u,v\\} \\neq \\varnothing$ by definition. If $s \\in$ `OPT` in _every_ round of the algorithm, then $S =$ `OPT`, which is awesome: and said awesomeness manifests with probability $1/2^k$. \n\nBonus: repeat the algorithm and retain the smallest solution to get an overall constant success probability:\n\n$$1-\\left(1-\\frac{1}{2^k}\\right)^{2^k} \\geqslant 1-1 / e.$$\n\n**Approximation.** Do we expect `ALG` to be a reasonable approximation? It turns out: yes! {{< bi emoji-sunglasses >}}\n\nIn particular: we will show that the size of the vertex cover output by `ALG` is at most twice $|$`OPT`$|$ in expectation.\n\nFor a graph $G$, define $X_G$ to be the radom variable returning the size of the set $S$ output by the algorithm.\n\nFor integers $k,n$ define:\n$$\nX_{n,k}=\\max_G E[X_G],\n$$\n\nwhere the $\\max$ is taken over all graphs with $\\leqslant n$ vertices^[We could have also considered $X_k = \\max_G E[X_G]$, where the max is over all graphs whose vertex cover is at most $k$: but there are infinitely many graphs that have vertex covers of size at most $k$, and it is not _immediate_ that the max is well-defined, so we restrict ourselves to graphs on $n$ vertices that have vertex covers of size at most $k$.] and vertex cover of size $\\leqslant k$. \n\nNow let's analyze the number $X_{n,k}$. Let $G^\\star$ be the \"worst-case graph\" that bears witness to the $\\max$ in the definition of $X_{n,k}$. Run the first step of `ALG` on $G^\\star$. Suppose we choose to pick ${\\color{indianred}s}$ in this step.\n$$\n\\begin{aligned}\nX_{n,k}=E[X_{G^\\star}] & = {\\color{indianred}1}+\\left(\\frac{1}{2}+\\varepsilon \\right) E\\left[{\\color{darkseagreen}X_{G^\\star-s} \\mid s \\in \\text{OPT}}\\right]+\\left(\\frac{1}{2} - \\varepsilon\\right) E\\left[{\\color{palevioletred}X_{G^\\star-s} \\mid s \\notin \\text {OPT}}\\right] \\\\\n& = 1 + \\left(\\frac{1}{2} + \\varepsilon \\right){\\color{darkseagreen}X_{n, k-1}}+ \\left(\\frac{1}{2} - \\varepsilon \\right){\\color{palevioletred}X_{n-1, k}}\\\\\n& \\leqslant 1 + \\left(\\frac{1}{2} + \\varepsilon \\right){\\color{darkseagreen}X_{n, k-1}}+ \\left(\\frac{1}{2} - \\varepsilon \\right){\\color{dodgerblue}X_{n, k}}\\\\\n& = 1 + \\frac{1}{2} X_{n, k-1} + \\varepsilon \\cdot X_{n, k-1} + \\frac{1}{2} X_{n, k} - \\varepsilon X_{n, k}\\\\\n& \\leqslant 1 + \\frac{1}{2} X_{n, k-1} + \\varepsilon \\cdot {\\color{dodgerblue}X_{n, k}} + \\frac{1}{2} X_{n, k} - \\varepsilon X_{n, k}\\\\\n& = 1 + \\frac{1}{2} X_{n, k-1} + {\\color{indianred}\\varepsilon \\cdot X_{n, k}} + \\frac{1}{2} X_{n, k} - {\\color{indianred}\\varepsilon X_{n, k}}\\\\\n& = 1 + \\frac{1}{2} X_{n, k-1} + \\frac{1}{2} X_{n, k} \n\\end{aligned}\n$$\n\nNote that:\n\n- <span style=\"color:dodgerblue;\"> $X_{n,k} \\geqslant X_{n-1,k}$ and  $X_{n,k} \\geqslant X_{n,k-1}$.</span>\n- $\\operatorname{Pr}[s \\in \\text{OPT}] \\geqslant \\frac{1}{2}$, in particular we let $\\operatorname{Pr}[s \\in \\text{OPT}] = \\frac{1}{2} + \\varepsilon$.\n- $\\operatorname{Pr}[s \\notin \\text{OPT}] = 1 - \\operatorname{Pr}[s \\in \\text{OPT}] = \\frac{1}{2} - \\varepsilon$.\n- <span style=\"color:darkseagreen;\"> ${\\color{darkseagreen}G^\\star-s}$ is a graph on at most ${\\color{darkseagreen}n}$ vertices with a vertex cover of size ${\\color{darkseagreen}\\leqslant k-1}$\n- <span style=\"color:palevioletred;\"> ${\\color{palevioletred}G^\\star-s}$ is a graph on at most ${\\color{palevioletred}n}$ vertices with a vertex cover of size ${\\color{palevioletred}\\leqslant k}$\n\nRearranging terms, we get:\n\n$$\\frac{1}{2} X_{n,k} \\leqslant 1 + \\frac{1}{2} X_{n,k-1} \\equiv X_{n,k} \\leqslant 2 + X_{n,k-1}$$\n\nExpanding the recurrence, we have: $X_{n,k} \\leqslant 2k$, as claimed earlier.\n\n\n### Feedback Vertex Set\n\nNow we turn to a problem similar to vertex cover, except that we are \"killing cycles\" instead of \"killing edges\".\n\n\n:::{.callout-tip}\n\n# Feedback Vertex Set\n\nInput: A (multi-)^[We allow for more than one edge between a fixed pair of vertices and self-loops.]graph $G = (V,E)$.\n\nTask: Find $S \\subseteq V(G)$ such that $G \\setminus S$ is a forest^[A graph without cycles that is not necessarily connected.], and <span style=\"color:indianred;\">minimize $|S|$</span>.\n\n:::\n\nIf we try to mimic the cute algorithm from before, we might easily be in trouble: note that the driving observation --- that an edge has at least one of its endpoints in the solution with a reasonable enough probability --- can fail spectacularly for FVS:\n\n![An example showing that for \"most edges\", _both_ endpoints do not belong to an optimal solution.](../images/fvs-badex.png){width=70%}\n\nOne thing about this example is the large number of pendant vertices sticking out prominently, and these clearly contribute to the badness of the situation. Happily, it turns out that we can get rid of these:\n\n\n:::{.callout-important icon=\"false\"}\n\n# Lemma 1. Delete pendant and isolated vertices\n\nLet $G$ be a multi-graph and $v$ be a vertex of degree $\\leqslant 1$. Then:\n\n- MinFVS of $G-\\{v\\}$ $\\leqslant$ MinFVS of $G$\n\n- $\\forall S \\subseteq V(G)-\\{v\\}$: <span style=\"color:#CC0000;\"> $S$ is an FVS for $G$ </span> $\\leftrightarrow$ <span style=\"color:#CC0000;\">$S$ is an FVS for $G \\setminus \\{v\\}$  </span>\n\n:::\n\nConsider graphs with no pendant vertices and fix an optimal FVS $S$. Is it true that a reasonable fraction of edges are guaranteed to be incident to $S$? Well... not yet:\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n\n# Spoiler\n\n![An(other) example showing that for \"most edges\", _both_ endpoints do not belong to an optimal solution, even though the graph has no pendant vertices.](../images/fvs-badex-deg2.png){width=70%}\n\n:::\n\nHowever, continuing our approach of conquering-by-observing-patterns-in-counterexamples, note that the example above has an _abundance_ of vertices that have degree two. Can we get rid of them? Well, isolated and pendant vertices were relatively easy because they don't even belong to cycles, but _that_ is not quite true for vertices of degree two. Can we still hope to shake them off?\n\nOne thing about a degree two vertex $u$ is that if there is a cycle that contains $u$ it _must_ contain both its neighbors^[Except when the cycle _only_ contains $u$, i.e, $u$ has a self-loop.]. So you might suggest that we can ditch $u$ and just work with its neighbors instead. This intuition, it turns out, can indeed be formalized:\n\n\n:::{.callout-important icon=\"false\"}\n\n# Lemma 2. Short-Circuiting Degree Two Vertices\n\nLet:\n\n- $G$ be a multi-graph,\n- $u$ be a vertex of degree 2 that is not a self-loop,\n- $a$ and $b$ be the neighbors of $u$ ($a=b$ is possible).\n\nLet $H$ be the graph obtained by adding an edge $(a,b)$ to $G-\\{u\\}$.\n\nThen:\n\n- every FVS $S$ of $G$ such that $u \\notin S$ is an FVS of $H$, and\n- every FVS $S$ of $H$ is an FVS of $G$.\n\n:::\n\n![Illustrating Lemma 2 scenarios.](../images/fvs-reduction-2deg.png)\n\nLet us also get rid of self-loops (because we can):\n\n:::{.callout-important icon=\"false\"}\n\n# Lemma 3. Removing self-loops\n\nIf $G$ has a vertex $v$ with a self loop then\n\n- Every FVS $S$ of $G$ contains $v$\n- For every $S$ containing $v$: <span style=\"color:#CC0000;\">$S$ is an FVS of $G$</span> $\\leftrightarrow$ <span style=\"color:#CC0000;\">$S-v$ is an FVS of $G-\\{v\\}$</span>\n\n:::\n\nNow let's apply Lemmas 1---3 exhaustively, which is to say we keep applying them until none of them are applicable (as opposed to applying them until we feel exhausted {{< bi emoji-laughing >}} ). Once we are truly stuck, we have a graph $H$ that is: (a) a graph whose _minimum_ degree is three; and (b) equivalent to the original $G$ in the sense that any minimum FVS for $H$ can be extended to a minimum FVS of $G$ by some time travel: just play back the applications of Lemmas 1---3 in reverse order.\n\nRecall that all this work was to serve our hope for having a cute algorithm for FVS as well. Let's check in on how we are doing on that front: consider graphs whose minimum degree is three and fix an optimal FVS $S$. Is it true that a reasonable fraction of edges are guaranteed to be incident to $S$? Or can we come up with examples to demonstrate otherwise?\n\nThis is a good place to pause and ponder: play around with examples to see if you can come up with bad cases as before. If you find yourself struggling, it would be for a good reason: we actually now _do_ have the property we were after! Here's the main claim that we want to make.\n\n:::{.callout-important icon=\"false\"}\n\n# Key Lemma\n\nLet:\n\n- $G$ be a multigraph with no self loops and minimum degree $\\geqslant 3$,\n- $S$ be an FVS of $G$,\n- $(u,v)$ be a random edge in $E(G)$. \n\nThen:\n\n$\\operatorname{Pr}[{\\color{indianred}\\{u, v\\} \\cap S \\neq \\varnothing}] \\geqslant 1/2$\n\n:::\n\nWe argue this as follows: call an edge <span style=\"color:darkseagreen;\">good</span> if it has at least one of its endpoints in $S$, and <span style=\"color:indianred;\">bad</span> otherwise. \n\nWe will demonstrate that the number of good edges is at least the number of bad edges: this implies the desired claim.\n\n- **The <span style=\"color:indianred;\">bad</span> edges.** Let $X := G \\setminus S$. The bad edges are precisely $E(G[X])$.\n\n- **The <span style=\"color:darkseagreen;\">good</span> edges.** Every edge that has one of its endpoints in $X$ and the other in $S$ is a good edge. Recall that $G$ has minimum degree three, because of which:\n\n    - for every leaf in $G[X]$, we have at least _two_ good edges, and\n    - for vertex that is degree two in $G[X]$, we have at least one good edge.\n\nSo at this point, it is enough to show that twice the number of leaves and degree two vertices is at least $|E(G[X])| = |X|-1$. But this is quite intuitive if we simple stare at the following mildly stronger claim:\n\n$$2 \\cdot (\\text{\\# leaves}) + \\text{\\# deg-} 2 \\text{vertices} \\geqslant |X|$$\n\nwhich is equivalent to:\n\n$$2 \\cdot ({\\color{darkseagreen}\\text{\\# leaves}}) + {\\color{palevioletred}\\text{\\# deg-}2 \\text{vertices}} \\geqslant ({\\color{darkseagreen}\\text{\\# leaves}}) + {\\color{palevioletred}\\text{\\# deg-}2 \\text{ vertices}} + \\text{\\# deg-}(\\geqslant 3) \\text{ vertices}.$$\n\nAfter cancelations, we have:\n\n$$(\\text{\\# leaves}) \\geqslant \\text{\\# deg-}(\\geqslant 3) \\text{ vertices}.$$\n\nNote that this is true! Intuitively, the inequality is suggesting every branching vertex in a tree pays for at least one leaf --- this can be formalized by induction on $n$. \n\n\n:::{.callout-caution collapse=\"true\"}\n# Induction proof sketch\nDenote the tree by $G$ and remove a leaf $u$ to obtain $H$. Apply the induction hypothesis on $H$. \n\n- If the neighbor of $u$ in $G$ is a degree two vertex, then the number of leaves and high degree vertices are the same in $G$ and $H$, so the claim follows directly. \n- If the degree of the neighbor in $u$ is three in $G$, then both quantities in the inequality for $H$ increase by one when we transition from $H$ to $G$. \n- In the only remaining case, the quantity on the left increases by one when we come to $G$, which bodes well for the inequality. {{< bi hand-thumbs-up >}}\n:::\n\nAll this was leading up to cute randomized algorithm v2.0 --- i.e, adapted for FVS as follows:\n\n:::{.callout-note}\n\n# Cute randomized algorithm redux\n\n`ALG`$(G)$\n\n`Preprocess:`\n\n- if $G$ is acyclic return $\\varnothing$\n- if $\\exists$ a self loop $v$ RETURN $($`ALG`$(G \\setminus \\{v\\})) \\cup \\{v\\}$.\n- if $\\exists$ a degree one vertex $v$ RETURN `ALG`$(G-\\{v\\})$.\n- if $\\exists$ a degree two vertex $v$ RETURN `ALG`$(G/\\{v\\})$ (c.f. Lemma 2).\n---\n\n`Mindeg-3 instance:`\n\n- pick an edge $(u,v) \\in E(G)$ u.a.r.\n- pick $s \\in \\{u,v\\}$ u.a.r.\n- RETURN $($`ALG`$(G \\setminus \\{s\\})) \\cup \\{s\\}$\n:::\n\n\n:::{.callout-important icon=\"false\"}\n\n# Claim 1\n\n`ALG` always returns a FVS of $G$.\n\n:::\n\nThis follows from Lemmas 1---3 and induction on $n$.\n\n\n:::{.callout-important icon=\"false\"}\n\n# Claim 2\n\nIf $G$ has a FVS of size $k$, then $\\operatorname{Pr}$[`ALG` returns an optimal FVS] $\\geqslant 1/4^k$.\n:::\n\nThis follows from Lemmas 1---3, the key lemma, and induction on $n$.\n\n\n### Exact Algorithms\n\n`Coming Soon.`\n\n<!-- The running time is then given by:\n\n$\\frac{{n \\choose t}}{{k \\choose t}} \\cdot c^{k-t}$\n\n$\\min_{t \\leqslant k} \\frac{{n \\choose t}}{{k \\choose t}} \\cdot c^{k-t}$\n\n$\\leqslant \\max_{k \\leqslant n} \\min _{t \\leqslant k} \\frac{{n \\choose t}}{k \\choose t} \\cdot c^{k-t}$\n\n$\\leqslant \\left(2-\\frac{1}{c}\\right)^n \\cdot \\operatorname{poly}(n)$\n\n\nThis leads to an $O(1.5^n)$ algorithm for Vertex Cover and an $O(1.75^n)$ algorithm for Feedback Vertex Set. -->\n\n\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["fontawesome"],"css":["../../../../styles.css","/css/teaching.css","/css/feedback-override.css"],"toc":false,"include-in-header":[{"text":"<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Berkshire+Swash&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap\" rel=\"stylesheet\">\n<link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n<script>\nwindow.addEventListener('load', function() {\n  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')); \n  tooltipTriggerList.forEach(function(element) {\n    new bootstrap.Tooltip(element, {\n      trigger: 'hover',\n      animation: true,\n      delay: { show: 50, hide: 50 }\n    });\n  });\n});\n</script>\n"}],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":"cosmo","js":"../../../../scripts.js","page-layout":"full","title":"191014K02 | Day 2 Lecture 1","sidebar":false},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}